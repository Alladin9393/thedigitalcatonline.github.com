<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>The Digital Cat - assembly</title><link href="http://blog.thedigitalcatonline.com/" rel="alternate"></link><link href="http://blog.thedigitalcatonline.com/categories/assembly/atom.xml" rel="self"></link><id>http://blog.thedigitalcatonline.com/</id><updated>2018-06-25T13:00:00+01:00</updated><entry><title>Exploring the Amiga - Part 6</title><link href="http://blog.thedigitalcatonline.com/blog/2018/06/25/exploring-the-amiga-6/" rel="alternate"></link><published>2018-06-25T13:00:00+01:00</published><updated>2018-06-25T13:00:00+01:00</updated><author><name>Leonardo Giordani</name></author><id>tag:blog.thedigitalcatonline.com,2018-06-25:/blog/2018/06/25/exploring-the-amiga-6/</id><summary type="html"></summary><content type="html">&lt;h1&gt;Memory initialisation&lt;/h1&gt;
&lt;p&gt;The Amiga has two types of memory. The first one is found on-board and it is traditionally referred to as "Chip Memory". This name comes from the fact that both the CPU and the custom chips have access to it, which also means that all this components have to share the access. This slows down the CPU when the custom chips are using the memory. While they can use DMA to access it without blocking the CPU, the memory cannot be accessed by multiple components at the same time.&lt;/p&gt;
&lt;p&gt;The second type of memory is called "Fast Memory" because the CPU has exclusive access to it, thus providing better performances. It is also referred to as "expansion memory" since it comes with expansion boards.&lt;/p&gt;
&lt;p&gt;At a certain point during boot time Kickstart figures out the types of memory installed in the Amiga machine and puts the expansion memory size in &lt;code&gt;a4&lt;/code&gt;. If this register contains a non-zero value, Kickstart knows that an expansion board has been installed and configures the memory accordingly.&lt;/p&gt;
&lt;p&gt;The memory initialisation code is the following&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;00000380:&lt;/span&gt; &lt;span class="mi"&gt;200c&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;00000382:&lt;/span&gt; &lt;span class="mi"&gt;6724&lt;/span&gt;                      &lt;span class="k"&gt;beq&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="mi"&gt;0x3a8&lt;/span&gt;
&lt;span class="nl"&gt;00000384:&lt;/span&gt; &lt;span class="mi"&gt;41ee&lt;/span&gt; &lt;span class="mi"&gt;024c&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x24c&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;
&lt;span class="nl"&gt;00000388:&lt;/span&gt; &lt;span class="mi"&gt;43fa&lt;/span&gt; &lt;span class="mi"&gt;ffa8&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x332&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;
&lt;span class="nl"&gt;0000038c:&lt;/span&gt; &lt;span class="mi"&gt;7400&lt;/span&gt;                      &lt;span class="k"&gt;moveq&lt;/span&gt;   &lt;span class="nl"&gt;#0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d2&lt;/span&gt;
&lt;span class="nl"&gt;0000038e:&lt;/span&gt; &lt;span class="mi"&gt;323c&lt;/span&gt; &lt;span class="mi"&gt;0005&lt;/span&gt;                 &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="nl"&gt;#0x5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;00000392:&lt;/span&gt; &lt;span class="mi"&gt;200c&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;00000394:&lt;/span&gt; &lt;span class="mi"&gt;9088&lt;/span&gt;                      &lt;span class="k"&gt;sub&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;   &lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;00000396:&lt;/span&gt; &lt;span class="mi"&gt;0480&lt;/span&gt; &lt;span class="mi"&gt;0000&lt;/span&gt; &lt;span class="mi"&gt;1800&lt;/span&gt;            &lt;span class="k"&gt;subi&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="nl"&gt;#0x1800&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;0000039c:&lt;/span&gt; &lt;span class="mi"&gt;6100&lt;/span&gt; &lt;span class="mi"&gt;1688&lt;/span&gt;                 &lt;span class="k"&gt;bsr&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;   &lt;span class="mi"&gt;0x1a26&lt;/span&gt;
&lt;span class="nl"&gt;000003a0:&lt;/span&gt; &lt;span class="mi"&gt;41f8&lt;/span&gt; &lt;span class="mi"&gt;0400&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x400&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;
&lt;span class="nl"&gt;000003a4:&lt;/span&gt; &lt;span class="mi"&gt;7000&lt;/span&gt;                      &lt;span class="k"&gt;moveq&lt;/span&gt;   &lt;span class="nl"&gt;#0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000003a6:&lt;/span&gt; &lt;span class="mi"&gt;600a&lt;/span&gt;                      &lt;span class="k"&gt;bra&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="mi"&gt;0x3b2&lt;/span&gt;
&lt;span class="nl"&gt;000003a8:&lt;/span&gt; &lt;span class="mi"&gt;41ee&lt;/span&gt; &lt;span class="mi"&gt;024c&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x24c&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;
&lt;span class="nl"&gt;000003ac:&lt;/span&gt; &lt;span class="mi"&gt;203c&lt;/span&gt; &lt;span class="mi"&gt;ffff&lt;/span&gt; &lt;span class="mi"&gt;e800&lt;/span&gt;            &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="p"&gt;#-&lt;/span&gt;&lt;span class="mi"&gt;0x1800&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000003b2:&lt;/span&gt; &lt;span class="mi"&gt;323c&lt;/span&gt; &lt;span class="mi"&gt;0003&lt;/span&gt;                 &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="nl"&gt;#0x3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;000003b6:&lt;/span&gt; &lt;span class="mi"&gt;2448&lt;/span&gt;                      &lt;span class="k"&gt;movea&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt; &lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a2&lt;/span&gt;
&lt;span class="nl"&gt;000003b8:&lt;/span&gt; &lt;span class="mi"&gt;43fa&lt;/span&gt; &lt;span class="mi"&gt;ff6c&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x326&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;
&lt;span class="nl"&gt;000003bc:&lt;/span&gt; &lt;span class="mi"&gt;74f6&lt;/span&gt;                      &lt;span class="k"&gt;moveq&lt;/span&gt;   &lt;span class="p"&gt;#-&lt;/span&gt;&lt;span class="mi"&gt;0xa&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d2&lt;/span&gt;
&lt;span class="nl"&gt;000003be:&lt;/span&gt; &lt;span class="o"&gt;d0&lt;/span&gt;&lt;span class="mi"&gt;8b&lt;/span&gt;                      &lt;span class="k"&gt;add&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;   &lt;span class="o"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000003c0:&lt;/span&gt; &lt;span class="mi"&gt;9088&lt;/span&gt;                      &lt;span class="k"&gt;sub&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;   &lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000003c2:&lt;/span&gt; &lt;span class="mi"&gt;6100&lt;/span&gt; &lt;span class="mi"&gt;1662&lt;/span&gt;                 &lt;span class="k"&gt;bsr&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;   &lt;span class="mi"&gt;0x1a26&lt;/span&gt;
&lt;span class="nl"&gt;000003c6:&lt;/span&gt; &lt;span class="mi"&gt;224e&lt;/span&gt;                      &lt;span class="k"&gt;movea&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt; &lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;
&lt;span class="nl"&gt;000003c8:&lt;/span&gt; &lt;span class="mi"&gt;6100&lt;/span&gt; &lt;span class="mi"&gt;107e&lt;/span&gt;                 &lt;span class="k"&gt;bsr&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;   &lt;span class="mi"&gt;0x1448&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As I did in the previous post I will split the code in parts and replace some addresses with labels to try and make the routine more understandable&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Check_expansion&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="nl"&gt;00000380:&lt;/span&gt; &lt;span class="mi"&gt;200c&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;00000382:&lt;/span&gt; &lt;span class="mi"&gt;6724&lt;/span&gt;                      &lt;span class="k"&gt;beq&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="n"&gt;Only_chip&lt;/span&gt;

&lt;span class="n"&gt;Add_expansion&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="nl"&gt;00000384:&lt;/span&gt; &lt;span class="mi"&gt;41ee&lt;/span&gt; &lt;span class="mi"&gt;024c&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x24c&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;
&lt;span class="nl"&gt;00000388:&lt;/span&gt; &lt;span class="mi"&gt;43fa&lt;/span&gt; &lt;span class="mi"&gt;ffa8&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x332&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;
&lt;span class="nl"&gt;0000038c:&lt;/span&gt; &lt;span class="mi"&gt;7400&lt;/span&gt;                      &lt;span class="k"&gt;moveq&lt;/span&gt;   &lt;span class="nl"&gt;#0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d2&lt;/span&gt;
&lt;span class="nl"&gt;0000038e:&lt;/span&gt; &lt;span class="mi"&gt;323c&lt;/span&gt; &lt;span class="mi"&gt;0005&lt;/span&gt;                 &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="nl"&gt;#0x5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;00000392:&lt;/span&gt; &lt;span class="mi"&gt;200c&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;00000394:&lt;/span&gt; &lt;span class="mi"&gt;9088&lt;/span&gt;                      &lt;span class="k"&gt;sub&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;   &lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;00000396:&lt;/span&gt; &lt;span class="mi"&gt;0480&lt;/span&gt; &lt;span class="mi"&gt;0000&lt;/span&gt; &lt;span class="mi"&gt;1800&lt;/span&gt;            &lt;span class="k"&gt;subi&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="nl"&gt;#0x1800&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;0000039c:&lt;/span&gt; &lt;span class="mi"&gt;6100&lt;/span&gt; &lt;span class="mi"&gt;1688&lt;/span&gt;                 &lt;span class="k"&gt;bsr&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;   &lt;span class="mi"&gt;0x1a26&lt;/span&gt;
&lt;span class="nl"&gt;000003a0:&lt;/span&gt; &lt;span class="mi"&gt;41f8&lt;/span&gt; &lt;span class="mi"&gt;0400&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x400&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;
&lt;span class="nl"&gt;000003a4:&lt;/span&gt; &lt;span class="mi"&gt;7000&lt;/span&gt;                      &lt;span class="k"&gt;moveq&lt;/span&gt;   &lt;span class="nl"&gt;#0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000003a6:&lt;/span&gt; &lt;span class="mi"&gt;600a&lt;/span&gt;                      &lt;span class="k"&gt;bra&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="n"&gt;Add_chip&lt;/span&gt;

&lt;span class="n"&gt;Only_chip&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="nl"&gt;000003a8:&lt;/span&gt; &lt;span class="mi"&gt;41ee&lt;/span&gt; &lt;span class="mi"&gt;024c&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x24c&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;
&lt;span class="nl"&gt;000003ac:&lt;/span&gt; &lt;span class="mi"&gt;203c&lt;/span&gt; &lt;span class="mi"&gt;ffff&lt;/span&gt; &lt;span class="mi"&gt;e800&lt;/span&gt;            &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="p"&gt;#-&lt;/span&gt;&lt;span class="mi"&gt;0x1800&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;

&lt;span class="n"&gt;Add_chip&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="nl"&gt;000003b2:&lt;/span&gt; &lt;span class="mi"&gt;323c&lt;/span&gt; &lt;span class="mi"&gt;0003&lt;/span&gt;                 &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="nl"&gt;#0x3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;000003b6:&lt;/span&gt; &lt;span class="mi"&gt;2448&lt;/span&gt;                      &lt;span class="k"&gt;movea&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt; &lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a2&lt;/span&gt;
&lt;span class="nl"&gt;000003b8:&lt;/span&gt; &lt;span class="mi"&gt;43fa&lt;/span&gt; &lt;span class="mi"&gt;ff6c&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x326&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;
&lt;span class="nl"&gt;000003bc:&lt;/span&gt; &lt;span class="mi"&gt;74f6&lt;/span&gt;                      &lt;span class="k"&gt;moveq&lt;/span&gt;   &lt;span class="p"&gt;#-&lt;/span&gt;&lt;span class="mi"&gt;0xa&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d2&lt;/span&gt;
&lt;span class="nl"&gt;000003be:&lt;/span&gt; &lt;span class="o"&gt;d0&lt;/span&gt;&lt;span class="mi"&gt;8b&lt;/span&gt;                      &lt;span class="k"&gt;add&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;   &lt;span class="o"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000003c0:&lt;/span&gt; &lt;span class="mi"&gt;9088&lt;/span&gt;                      &lt;span class="k"&gt;sub&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;   &lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000003c2:&lt;/span&gt; &lt;span class="mi"&gt;6100&lt;/span&gt; &lt;span class="mi"&gt;1662&lt;/span&gt;                 &lt;span class="k"&gt;bsr&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;   &lt;span class="mi"&gt;0x1a26&lt;/span&gt;
&lt;span class="nl"&gt;000003c6:&lt;/span&gt; &lt;span class="mi"&gt;224e&lt;/span&gt;                      &lt;span class="k"&gt;movea&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt; &lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;
&lt;span class="nl"&gt;000003c8:&lt;/span&gt; &lt;span class="mi"&gt;6100&lt;/span&gt; &lt;span class="mi"&gt;107e&lt;/span&gt;                 &lt;span class="k"&gt;bsr&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;   &lt;span class="mi"&gt;0x1448&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The two addresses &lt;code&gt;0x326&lt;/code&gt; and &lt;code&gt;0x332&lt;/code&gt; mentioned in the code contain the two zero-terminated strings &lt;code&gt;Chip Memory&lt;/code&gt; and &lt;code&gt;Fast Memory&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Chip Memory&amp;quot;&lt;/span&gt;

&lt;span class="nt"&gt;00000326&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;4368&lt;/span&gt; &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;Ch&lt;/span&gt;
&lt;span class="nt"&gt;00000328&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;6970&lt;/span&gt; &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;ip&lt;/span&gt;
&lt;span class="nt"&gt;0000032a&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;204d&lt;/span&gt; &lt;span class="o"&gt;;&lt;/span&gt;  &lt;span class="nt"&gt;M&lt;/span&gt;
&lt;span class="nt"&gt;0000032c&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;656d&lt;/span&gt; &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;em&lt;/span&gt;
&lt;span class="nt"&gt;0000032e&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;6f72&lt;/span&gt; &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;or&lt;/span&gt;
&lt;span class="nt"&gt;00000330&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;7900&lt;/span&gt; &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;y&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;0&lt;/span&gt;

&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Fast Memory&amp;quot;&lt;/span&gt;

&lt;span class="nt"&gt;00000332&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;4661&lt;/span&gt; &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;Fa&lt;/span&gt;
&lt;span class="nt"&gt;00000334&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;7374&lt;/span&gt; &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;st&lt;/span&gt;
&lt;span class="nt"&gt;00000336&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;204d&lt;/span&gt; &lt;span class="o"&gt;;&lt;/span&gt;  &lt;span class="nt"&gt;M&lt;/span&gt;
&lt;span class="nt"&gt;00000338&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;656d&lt;/span&gt; &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;em&lt;/span&gt;
&lt;span class="nt"&gt;0000033a&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;6f72&lt;/span&gt; &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;or&lt;/span&gt;
&lt;span class="nt"&gt;0000033c&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;7900&lt;/span&gt; &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;y&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Let's analyse the code line by line.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Check_expansion&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="nl"&gt;00000380:&lt;/span&gt; &lt;span class="mi"&gt;200c&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;00000382:&lt;/span&gt; &lt;span class="mi"&gt;6724&lt;/span&gt;                      &lt;span class="k"&gt;beq&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="n"&gt;Only_chip&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The first thing that Kickstart does is to check if &lt;code&gt;a4&lt;/code&gt; contains a non-zero value, which signals that we have a memory expansion board available. If &lt;code&gt;a4&lt;/code&gt; is zero the code jumps to the part that initialises chip memory only.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Add_expansion&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="nl"&gt;00000384:&lt;/span&gt; &lt;span class="mi"&gt;41ee&lt;/span&gt; &lt;span class="mi"&gt;024c&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x24c&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;
&lt;span class="nl"&gt;00000388:&lt;/span&gt; &lt;span class="mi"&gt;43fa&lt;/span&gt; &lt;span class="mi"&gt;ffa8&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x332&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The code then loads two effective addresses. The first one is the first free location (&lt;code&gt;0x24c&lt;/code&gt;) and the second one is the string &lt;code&gt;Fast Memory&lt;/code&gt;. The reason behind the address &lt;code&gt;0x24c&lt;/code&gt; is explained in a later section in detail.&lt;/p&gt;
&lt;p&gt;The purpose of the code is to call the &lt;code&gt;AddMemList&lt;/code&gt; routine, which adds the memory to the system free memory pool. It has the following prototype&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="n"&gt;error&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AddMemList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;attributes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pri&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="n"&gt;D0&lt;/span&gt;                  &lt;span class="n"&gt;D0&lt;/span&gt;    &lt;span class="n"&gt;D1&lt;/span&gt;          &lt;span class="n"&gt;D2&lt;/span&gt;   &lt;span class="n"&gt;A0&lt;/span&gt;    &lt;span class="n"&gt;A1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;where &lt;code&gt;size&lt;/code&gt; is the size of the memory (bytes), &lt;code&gt;attributes&lt;/code&gt; contains flags that identify memory attributes, &lt;code&gt;pri&lt;/code&gt; is the priority of the memory, &lt;code&gt;base&lt;/code&gt; is the base address of the new area and &lt;code&gt;name&lt;/code&gt; is a name for this list.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;0000038c:&lt;/span&gt; &lt;span class="mi"&gt;7400&lt;/span&gt;                      &lt;span class="k"&gt;moveq&lt;/span&gt;   &lt;span class="nl"&gt;#0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d2&lt;/span&gt;
&lt;span class="nl"&gt;0000038e:&lt;/span&gt; &lt;span class="mi"&gt;323c&lt;/span&gt; &lt;span class="mi"&gt;0005&lt;/span&gt;                 &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="nl"&gt;#0x5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The code then prepares the registers for the &lt;code&gt;AddMemList&lt;/code&gt; call. It gives this memory priority &lt;code&gt;0&lt;/code&gt; and sets the &lt;code&gt;attributes&lt;/code&gt; flags to &lt;code&gt;0x5&lt;/code&gt;, which is &lt;code&gt;101&lt;/code&gt;, or &lt;code&gt;PUBLIC&lt;/code&gt; and &lt;code&gt;FAST&lt;/code&gt; (see &lt;code&gt;include_i/exec/memory.i&lt;/code&gt;).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;00000392:&lt;/span&gt; &lt;span class="mi"&gt;200c&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;00000394:&lt;/span&gt; &lt;span class="mi"&gt;9088&lt;/span&gt;                      &lt;span class="k"&gt;sub&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;   &lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;00000396:&lt;/span&gt; &lt;span class="mi"&gt;0480&lt;/span&gt; &lt;span class="mi"&gt;0000&lt;/span&gt; &lt;span class="mi"&gt;1800&lt;/span&gt;            &lt;span class="k"&gt;subi&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="nl"&gt;#0x1800&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;0000039c:&lt;/span&gt; &lt;span class="mi"&gt;6100&lt;/span&gt; &lt;span class="mi"&gt;1688&lt;/span&gt;                 &lt;span class="k"&gt;bsr&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;   &lt;span class="mi"&gt;0x1a26&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The expansion memory base address is copied in &lt;code&gt;d0&lt;/code&gt; (this is actually an unneeded repetition of what the code did 6 lines before, I think). It then subtracts the address of the first free location (because if this is not 0 it means that something is already stored in memory) and the size of the stack, that was initialised previously by Kickstart to 6 KBytes (hardcoded). After that the code jumps to &lt;code&gt;AddMemList&lt;/code&gt; (&lt;code&gt;0x1a26&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;When the routine returns the code has to move on initialising the chip memory. The chip memory has to be initialised in two different ways depending on the presence of the expansion memory, as this latter is preferably used by the CPU.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;000003&lt;/span&gt;&lt;span class="n"&gt;a0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;41&lt;/span&gt;&lt;span class="n"&gt;f8&lt;/span&gt; &lt;span class="mi"&gt;0400&lt;/span&gt;                 &lt;span class="n"&gt;lea&lt;/span&gt;     &lt;span class="mh"&gt;0x400&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;w&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;a0&lt;/span&gt;
&lt;span class="mi"&gt;000003&lt;/span&gt;&lt;span class="n"&gt;a4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;7000&lt;/span&gt;                      &lt;span class="n"&gt;moveq&lt;/span&gt;   &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;d0&lt;/span&gt;
&lt;span class="mi"&gt;000003&lt;/span&gt;&lt;span class="n"&gt;a6&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;600&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;                      &lt;span class="n"&gt;bra&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;b&lt;/span&gt;   &lt;span class="n"&gt;Add_chip&lt;/span&gt;

&lt;span class="n"&gt;Only_chip&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="mi"&gt;000003&lt;/span&gt;&lt;span class="n"&gt;a8&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;41&lt;/span&gt;&lt;span class="n"&gt;ee&lt;/span&gt; &lt;span class="mi"&gt;024&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;                 &lt;span class="n"&gt;lea&lt;/span&gt;     &lt;span class="mh"&gt;0x24c&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a6&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt;&lt;span class="n"&gt;a0&lt;/span&gt;
&lt;span class="mi"&gt;000003&lt;/span&gt;&lt;span class="n"&gt;ac&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;203&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;ffff&lt;/span&gt; &lt;span class="n"&gt;e800&lt;/span&gt;            &lt;span class="n"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;l&lt;/span&gt;  &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;0x1800&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;d0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If the initial test on the presence of the expansion memory fails the code jumps directly to &lt;code&gt;0x03a8&lt;/code&gt;. If the expansion memory has already been initialised, instead, the CPU executes the code at &lt;code&gt;0x03a0&lt;/code&gt; and then jumps to &lt;code&gt;0x03b2&lt;/code&gt; (Renamed &lt;code&gt;Add_chip&lt;/code&gt; here).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000003a0:&lt;/span&gt; &lt;span class="mi"&gt;41f8&lt;/span&gt; &lt;span class="mi"&gt;0400&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x400&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So if there is expansion memory, Exec will be loaded there, which means that both it and the system stack are not in the chip memory. We can then add the whole space above &lt;code&gt;0x400&lt;/code&gt; (more on this number in a later section)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000003a4:&lt;/span&gt; &lt;span class="mi"&gt;7000&lt;/span&gt;                      &lt;span class="k"&gt;moveq&lt;/span&gt;   &lt;span class="nl"&gt;#0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000003a6:&lt;/span&gt; &lt;span class="mi"&gt;600a&lt;/span&gt;                      &lt;span class="k"&gt;bra&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="n"&gt;Add_chip&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Since the stack has already been created in fast memory we can store a 0 in &lt;code&gt;d0&lt;/code&gt; and jump to the code that adds the memory to the system lists&lt;/p&gt;
&lt;p&gt;If the expansion is not present, instead, Exec is installed in the chip memory, so we compute the base like we did for the fast memory.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Only_chip&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="nl"&gt;000003a8:&lt;/span&gt; &lt;span class="mi"&gt;41ee&lt;/span&gt; &lt;span class="mi"&gt;024c&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x24c&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;
&lt;span class="nl"&gt;000003ac:&lt;/span&gt; &lt;span class="mi"&gt;203c&lt;/span&gt; &lt;span class="mi"&gt;ffff&lt;/span&gt; &lt;span class="mi"&gt;e800&lt;/span&gt;            &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="p"&gt;#-&lt;/span&gt;&lt;span class="mi"&gt;0x1800&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here we load the effective address of the first free location, &lt;code&gt;0x24c&lt;/code&gt; bytes after the ExecBase address, and we specify the size of the memory as 6 Kbytes less than the maximum, to keep some space for the system stack. The size is negative as later the memory size will be added to the register.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Add_chip&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="nl"&gt;000003b2:&lt;/span&gt; &lt;span class="mi"&gt;323c&lt;/span&gt; &lt;span class="mi"&gt;0003&lt;/span&gt;                 &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="nl"&gt;#0x3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;000003b6:&lt;/span&gt; &lt;span class="mi"&gt;2448&lt;/span&gt;                      &lt;span class="k"&gt;movea&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt; &lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a2&lt;/span&gt;
&lt;span class="nl"&gt;000003b8:&lt;/span&gt; &lt;span class="mi"&gt;43fa&lt;/span&gt; &lt;span class="mi"&gt;ff6c&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x326&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;
&lt;span class="nl"&gt;000003bc:&lt;/span&gt; &lt;span class="mi"&gt;74f6&lt;/span&gt;                      &lt;span class="k"&gt;moveq&lt;/span&gt;   &lt;span class="p"&gt;#-&lt;/span&gt;&lt;span class="mi"&gt;0xa&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d2&lt;/span&gt;
&lt;span class="nl"&gt;000003be:&lt;/span&gt; &lt;span class="o"&gt;d0&lt;/span&gt;&lt;span class="mi"&gt;8b&lt;/span&gt;                      &lt;span class="k"&gt;add&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;   &lt;span class="o"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000003c0:&lt;/span&gt; &lt;span class="mi"&gt;9088&lt;/span&gt;                      &lt;span class="k"&gt;sub&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;   &lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000003c2:&lt;/span&gt; &lt;span class="mi"&gt;6100&lt;/span&gt; &lt;span class="mi"&gt;1662&lt;/span&gt;                 &lt;span class="k"&gt;bsr&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;   &lt;span class="mi"&gt;0x1a26&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;After this we repeat the same procedure that was described for the fast memory. The attributes are now &lt;code&gt;CHIP&lt;/code&gt; and &lt;code&gt;PUBLIC&lt;/code&gt; (&lt;code&gt;0x3&lt;/code&gt;), the string at &lt;code&gt;0x326&lt;/code&gt; is &lt;code&gt;Chip Memory&lt;/code&gt;, and the priority is -10 (&lt;code&gt;-0xa&lt;/code&gt;). The &lt;code&gt;a3&lt;/code&gt; register already contains the end address of the chip memory, so we add it to &lt;code&gt;d0&lt;/code&gt; and then subtract the first free location computed before to get the size of the memory. As happened before, the routine calls &lt;code&gt;AddMemList&lt;/code&gt; at &lt;code&gt;0x1a26&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000003c6:&lt;/span&gt; &lt;span class="mi"&gt;224e&lt;/span&gt;                      &lt;span class="k"&gt;movea&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt; &lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;
&lt;span class="nl"&gt;000003c8:&lt;/span&gt; &lt;span class="mi"&gt;6100&lt;/span&gt; &lt;span class="mi"&gt;107e&lt;/span&gt;                 &lt;span class="k"&gt;bsr&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;   &lt;span class="mi"&gt;0x1448&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The last action of this part of the code is to call &lt;code&gt;AddLibrary&lt;/code&gt; at &lt;code&gt;0x1448&lt;/code&gt;. The only parameter the routine requires is the base address of the library in &lt;code&gt;a1&lt;/code&gt;, which is why the code copies &lt;code&gt;a6&lt;/code&gt; there.&lt;/p&gt;
&lt;h1&gt;The "magic number" &lt;code&gt;0x24c&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;When we discussed the way the memory is initialised we discovered a "magic number" that Kickstart uses to find the first free location in memory&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;00000384:&lt;/span&gt; &lt;span class="mi"&gt;41ee&lt;/span&gt; &lt;span class="mi"&gt;024c&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x24c&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The first free location, according to this code is &lt;code&gt;0x24c&lt;/code&gt; (588) bytes after the Exec base address. The reason behind this number is simple. When the Exec library is installed its structures use exactly 588 bytes, thus that is the address of the first free space in memory.&lt;/p&gt;
&lt;p&gt;It's easy to calculate this number. Here you find the annotated version of the &lt;code&gt;ExecBase&lt;/code&gt; structure that I already used in the previous instalment.&lt;/p&gt;
&lt;p&gt;The structure is described in the &lt;code&gt;include_i/exec/execbase.i&lt;/code&gt; include file, and I added the displacement in bytes of each field. The first column is the displacement in the &lt;code&gt;ExecBase&lt;/code&gt; structure, while the second starts from &lt;code&gt;0x22&lt;/code&gt;. This latter comes from the fact that the structure follows an &lt;code&gt;LN&lt;/code&gt; structure and a &lt;code&gt;LIB&lt;/code&gt; structure, described in the fourth instalment of this series.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;0000&lt;/span&gt; &lt;span class="mi"&gt;0022&lt;/span&gt;    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;SoftVer&lt;/span&gt; &lt;span class="c1"&gt;; kickstart release number (obs.)&lt;/span&gt;
&lt;span class="mi"&gt;0002&lt;/span&gt; &lt;span class="mi"&gt;0024&lt;/span&gt;    &lt;span class="n"&gt;WORD&lt;/span&gt;    &lt;span class="n"&gt;LowMemChkSum&lt;/span&gt;    &lt;span class="c1"&gt;; checksum of 68000 trap vectors&lt;/span&gt;
&lt;span class="mi"&gt;0004&lt;/span&gt; &lt;span class="mi"&gt;0026&lt;/span&gt;    &lt;span class="n"&gt;ULONG&lt;/span&gt;   &lt;span class="n"&gt;ChkBase&lt;/span&gt; &lt;span class="c1"&gt;; system base pointer complement&lt;/span&gt;
&lt;span class="mi"&gt;0008&lt;/span&gt; &lt;span class="mi"&gt;002a&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;ColdCapture&lt;/span&gt; &lt;span class="c1"&gt;; coldstart soft capture vector&lt;/span&gt;
&lt;span class="mi"&gt;000c&lt;/span&gt; &lt;span class="mi"&gt;002e&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;CoolCapture&lt;/span&gt; &lt;span class="c1"&gt;; coolstart soft capture vector&lt;/span&gt;
&lt;span class="mi"&gt;0010&lt;/span&gt; &lt;span class="mi"&gt;0032&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;WarmCapture&lt;/span&gt; &lt;span class="c1"&gt;; warmstart soft capture vector&lt;/span&gt;
&lt;span class="mi"&gt;0014&lt;/span&gt; &lt;span class="mi"&gt;0036&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;SysStkUpper&lt;/span&gt; &lt;span class="c1"&gt;; system stack base   (upper bound)&lt;/span&gt;
&lt;span class="mi"&gt;0018&lt;/span&gt; &lt;span class="mi"&gt;003a&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;SysStkLower&lt;/span&gt; &lt;span class="c1"&gt;; top of system stack (lower bound)&lt;/span&gt;
&lt;span class="mi"&gt;001c&lt;/span&gt; &lt;span class="mi"&gt;003e&lt;/span&gt;    &lt;span class="n"&gt;ULONG&lt;/span&gt;   &lt;span class="n"&gt;MaxLocMem&lt;/span&gt;   &lt;span class="c1"&gt;; top of chip memory&lt;/span&gt;
&lt;span class="mi"&gt;0020&lt;/span&gt; &lt;span class="mi"&gt;0042&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;DebugEntry&lt;/span&gt;  &lt;span class="c1"&gt;; global debugger entry point&lt;/span&gt;
&lt;span class="mi"&gt;0024&lt;/span&gt; &lt;span class="mi"&gt;0046&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;DebugData&lt;/span&gt;   &lt;span class="c1"&gt;; global debugger data segment&lt;/span&gt;
&lt;span class="mi"&gt;0028&lt;/span&gt; &lt;span class="mi"&gt;004a&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;AlertData&lt;/span&gt;   &lt;span class="c1"&gt;; alert data segment&lt;/span&gt;
&lt;span class="mi"&gt;002c&lt;/span&gt; &lt;span class="mi"&gt;004e&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;MaxExtMem&lt;/span&gt;   &lt;span class="c1"&gt;; top of extended mem, or null if none&lt;/span&gt;

&lt;span class="mi"&gt;0030&lt;/span&gt; &lt;span class="mi"&gt;0052&lt;/span&gt;    &lt;span class="n"&gt;WORD&lt;/span&gt;    &lt;span class="n"&gt;ChkSum&lt;/span&gt;      &lt;span class="c1"&gt;; for all of the above (minus 2)&lt;/span&gt;


&lt;span class="c1"&gt;******* Interrupt Related ********************************************&lt;/span&gt;

    &lt;span class="n"&gt;LABEL&lt;/span&gt;   &lt;span class="n"&gt;IntVects&lt;/span&gt;
&lt;span class="mi"&gt;0032&lt;/span&gt; &lt;span class="mi"&gt;0054&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVTBE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;003e&lt;/span&gt; &lt;span class="mi"&gt;0060&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVDSKBLK&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;004a&lt;/span&gt; &lt;span class="mi"&gt;006c&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVSOFTINT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;0056&lt;/span&gt; &lt;span class="mi"&gt;0078&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVPORTS&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;0062&lt;/span&gt; &lt;span class="mi"&gt;0084&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVCOPER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;006e&lt;/span&gt; &lt;span class="mi"&gt;0090&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVVERTB&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;007a&lt;/span&gt; &lt;span class="mi"&gt;009c&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVBLIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;0086&lt;/span&gt; &lt;span class="mi"&gt;00a8&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVAUD0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;0092&lt;/span&gt; &lt;span class="mi"&gt;00b4&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVAUD1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;009e&lt;/span&gt; &lt;span class="mi"&gt;00c0&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVAUD2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;00aa&lt;/span&gt; &lt;span class="mi"&gt;00cc&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVAUD3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;00b6&lt;/span&gt; &lt;span class="mi"&gt;00d8&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVRBF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;00c2&lt;/span&gt; &lt;span class="mi"&gt;00e4&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVDSKSYNC&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;00ce&lt;/span&gt; &lt;span class="mi"&gt;00f0&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVEXTER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;00da&lt;/span&gt; &lt;span class="mi"&gt;00fc&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVINTEN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;00e6&lt;/span&gt; &lt;span class="mi"&gt;0108&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVNMI&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;


&lt;span class="c1"&gt;******* Dynamic System Variables *************************************&lt;/span&gt;

&lt;span class="mi"&gt;00f2&lt;/span&gt; &lt;span class="mi"&gt;0114&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;ThisTask&lt;/span&gt;    &lt;span class="c1"&gt;; pointer to current task (readable)&lt;/span&gt;

&lt;span class="mi"&gt;00f6&lt;/span&gt; &lt;span class="mi"&gt;0118&lt;/span&gt;    &lt;span class="n"&gt;ULONG&lt;/span&gt;   &lt;span class="n"&gt;IdleCount&lt;/span&gt;   &lt;span class="c1"&gt;; idle counter&lt;/span&gt;
&lt;span class="mi"&gt;00fa&lt;/span&gt; &lt;span class="mi"&gt;011c&lt;/span&gt;    &lt;span class="n"&gt;ULONG&lt;/span&gt;   &lt;span class="n"&gt;DispCount&lt;/span&gt;   &lt;span class="c1"&gt;; dispatch counter&lt;/span&gt;
&lt;span class="mi"&gt;00fe&lt;/span&gt; &lt;span class="mi"&gt;0120&lt;/span&gt;    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;Quantum&lt;/span&gt; &lt;span class="c1"&gt;; time slice quantum&lt;/span&gt;
&lt;span class="mi"&gt;0100&lt;/span&gt; &lt;span class="mi"&gt;0122&lt;/span&gt;    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;Elapsed&lt;/span&gt; &lt;span class="c1"&gt;; current quantum ticks&lt;/span&gt;
&lt;span class="mi"&gt;0102&lt;/span&gt; &lt;span class="mi"&gt;0124&lt;/span&gt;    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;SysFlags&lt;/span&gt;    &lt;span class="c1"&gt;; misc internal system flags&lt;/span&gt;
&lt;span class="mi"&gt;0104&lt;/span&gt; &lt;span class="mi"&gt;0126&lt;/span&gt;    &lt;span class="n"&gt;BYTE&lt;/span&gt;    &lt;span class="n"&gt;IDNestCnt&lt;/span&gt;   &lt;span class="c1"&gt;; interrupt disable nesting count&lt;/span&gt;
&lt;span class="mi"&gt;0105&lt;/span&gt; &lt;span class="mi"&gt;0127&lt;/span&gt;    &lt;span class="n"&gt;BYTE&lt;/span&gt;    &lt;span class="n"&gt;TDNestCnt&lt;/span&gt;   &lt;span class="c1"&gt;; task disable nesting count&lt;/span&gt;

&lt;span class="mi"&gt;0106&lt;/span&gt; &lt;span class="mi"&gt;0128&lt;/span&gt;    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;AttnFlags&lt;/span&gt;   &lt;span class="c1"&gt;; special attention flags (readable)&lt;/span&gt;

&lt;span class="mi"&gt;0108&lt;/span&gt; &lt;span class="mi"&gt;012a&lt;/span&gt;    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;AttnResched&lt;/span&gt; &lt;span class="c1"&gt;; rescheduling attention&lt;/span&gt;
&lt;span class="mi"&gt;010a&lt;/span&gt; &lt;span class="mi"&gt;012c&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;ResModules&lt;/span&gt;  &lt;span class="c1"&gt;; pointer to resident module array&lt;/span&gt;
&lt;span class="mi"&gt;010e&lt;/span&gt; &lt;span class="mi"&gt;0130&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;TaskTrapCode&lt;/span&gt;    &lt;span class="c1"&gt;; default task trap routine&lt;/span&gt;
&lt;span class="mi"&gt;0112&lt;/span&gt; &lt;span class="mi"&gt;0134&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;TaskExceptCode&lt;/span&gt;  &lt;span class="c1"&gt;; default task exception code&lt;/span&gt;
&lt;span class="mi"&gt;0116&lt;/span&gt; &lt;span class="mi"&gt;0138&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;TaskExitCode&lt;/span&gt;    &lt;span class="c1"&gt;; default task exit code&lt;/span&gt;
&lt;span class="mi"&gt;011a&lt;/span&gt; &lt;span class="mi"&gt;013c&lt;/span&gt;    &lt;span class="n"&gt;ULONG&lt;/span&gt;   &lt;span class="n"&gt;TaskSigAlloc&lt;/span&gt;    &lt;span class="c1"&gt;; preallocated signal mask&lt;/span&gt;
&lt;span class="mi"&gt;011e&lt;/span&gt; &lt;span class="mi"&gt;0140&lt;/span&gt;    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;TaskTrapAlloc&lt;/span&gt;   &lt;span class="c1"&gt;; preallocated trap mask&lt;/span&gt;


&lt;span class="c1"&gt;******* System List Headers (private!) ********************************&lt;/span&gt;

&lt;span class="mi"&gt;0120&lt;/span&gt; &lt;span class="mi"&gt;0142&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;MemList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;012e&lt;/span&gt; &lt;span class="mi"&gt;0150&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;ResourceList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;013c&lt;/span&gt; &lt;span class="mi"&gt;015e&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;DeviceList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;014a&lt;/span&gt; &lt;span class="mi"&gt;016c&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IntrList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;0158&lt;/span&gt; &lt;span class="mi"&gt;017a&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;LibList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;0166&lt;/span&gt; &lt;span class="mi"&gt;0188&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;PortList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;0174&lt;/span&gt; &lt;span class="mi"&gt;0196&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;TaskReady&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;0182&lt;/span&gt; &lt;span class="mi"&gt;01a4&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;TaskWait&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;0190&lt;/span&gt; &lt;span class="mi"&gt;01b2&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;SoftInts&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SH_SIZE&lt;/span&gt;&lt;span class="c1"&gt;*5&lt;/span&gt;

&lt;span class="mi"&gt;01e0&lt;/span&gt; &lt;span class="mi"&gt;0202&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;LastAlert&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="c1"&gt;*4&lt;/span&gt;

&lt;span class="mi"&gt;01f0&lt;/span&gt; &lt;span class="mi"&gt;0212&lt;/span&gt;    &lt;span class="n"&gt;UBYTE&lt;/span&gt;   &lt;span class="n"&gt;VBlankFrequency&lt;/span&gt;     &lt;span class="c1"&gt;;(readable)&lt;/span&gt;
&lt;span class="mi"&gt;01f1&lt;/span&gt; &lt;span class="mi"&gt;0213&lt;/span&gt;    &lt;span class="n"&gt;UBYTE&lt;/span&gt;   &lt;span class="n"&gt;PowerSupplyFrequency&lt;/span&gt;    &lt;span class="c1"&gt;;(readable)&lt;/span&gt;

&lt;span class="mi"&gt;01f2&lt;/span&gt; &lt;span class="mi"&gt;0214&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;SemaphoreList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;

&lt;span class="mi"&gt;0200&lt;/span&gt; &lt;span class="mi"&gt;0222&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;KickMemPtr&lt;/span&gt;  &lt;span class="c1"&gt;; ptr to queue of mem lists&lt;/span&gt;
&lt;span class="mi"&gt;0204&lt;/span&gt; &lt;span class="mi"&gt;0226&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;KickTagPtr&lt;/span&gt;  &lt;span class="c1"&gt;; ptr to rom tag queue&lt;/span&gt;
&lt;span class="mi"&gt;0208&lt;/span&gt; &lt;span class="mi"&gt;022a&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;KickCheckSum&lt;/span&gt;    &lt;span class="c1"&gt;; checksum for mem and tags&lt;/span&gt;

&lt;span class="mi"&gt;020c&lt;/span&gt; &lt;span class="mi"&gt;022e&lt;/span&gt;    &lt;span class="n"&gt;UBYTE&lt;/span&gt; &lt;span class="n"&gt;ExecBaseReserved&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
&lt;span class="mi"&gt;0216&lt;/span&gt; &lt;span class="mi"&gt;0238&lt;/span&gt;    &lt;span class="n"&gt;UBYTE&lt;/span&gt; &lt;span class="n"&gt;ExecBaseNewReserved&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
&lt;span class="mi"&gt;022a&lt;/span&gt; &lt;span class="mi"&gt;024c&lt;/span&gt;    &lt;span class="n"&gt;LABEL&lt;/span&gt;   &lt;span class="n"&gt;SYSBASESIZE&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The include file that I found in the Amiga Developer CD has a slightly different version of this structure that contains fields from higher versions of Exec. This structure can be found in the Amiga System Programmer's Guide, page 308. You can easily find the definitions of values like &lt;code&gt;SH_SIZE&lt;/code&gt; in the include files contained in the &lt;code&gt;include_i/exec/&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;As you can see the final address is &lt;code&gt;0x24c&lt;/code&gt;, which is exactly where the free memory begins (remember that &lt;code&gt;LABEL&lt;/code&gt; is a macro and not a field, so it doesn't use space).&lt;/p&gt;
&lt;h1&gt;The "magic numbers" &lt;code&gt;0x676&lt;/code&gt; and &lt;code&gt;0x400&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;The Motorola 68000 architecture forces to reserve the first 1024 bytes (&lt;code&gt;0x400&lt;/code&gt;) for the exception vectors. The table of these vectors can be found in the Programmer's Reference Manual, page B-2, and this is the source for the magic number used when adding the chip memory to the system lists in case an expansion memory is installed.&lt;/p&gt;
&lt;p&gt;The Exec base address, however, is not &lt;code&gt;0x400&lt;/code&gt; but &lt;code&gt;0x676&lt;/code&gt;. As we already know the library is preceded by the jump table, and since Exec exports 105 functions we use &lt;code&gt;105*6 = 630&lt;/code&gt; bytes (&lt;code&gt;0x676&lt;/code&gt;) for the jump vectors.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="o"&gt;+---------------------------------------+&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt; First free address                    &lt;span class="o"&gt;|&lt;/span&gt;
   &lt;span class="m"&gt;2242&lt;/span&gt; &lt;span class="o"&gt;+---------------------------------------+&lt;/span&gt; &lt;span class="mh"&gt;0x8c2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-+&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt; ExecBase structure                    &lt;span class="o"&gt;|&lt;/span&gt;         &lt;span class="o"&gt;|&lt;/span&gt;
   &lt;span class="m"&gt;1688&lt;/span&gt; &lt;span class="o"&gt;+---------------------------------------+&lt;/span&gt; &lt;span class="mh"&gt;0x698&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt; LIB structure                         &lt;span class="o"&gt;|&lt;/span&gt;         &lt;span class="o"&gt;|&lt;/span&gt; Exec base
   &lt;span class="m"&gt;1668&lt;/span&gt; &lt;span class="o"&gt;+---------------------------------------+&lt;/span&gt; &lt;span class="mh"&gt;0x684&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kp"&gt;structure&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt; LN structure                          &lt;span class="o"&gt;|&lt;/span&gt;         &lt;span class="o"&gt;|&lt;/span&gt;
   &lt;span class="m"&gt;1654&lt;/span&gt; &lt;span class="o"&gt;+---------------------------------------+&lt;/span&gt; &lt;span class="mh"&gt;0x676&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-+&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt; Jump &lt;span class="kt"&gt;vector&lt;/span&gt; &lt;span class="c1"&gt;#105                      |         |&lt;/span&gt;
        &lt;span class="o"&gt;+---------------------------------------+&lt;/span&gt;         &lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kc"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;                                 &lt;span class="o"&gt;|&lt;/span&gt;         &lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="o"&gt;+---------------------------------------+&lt;/span&gt;         &lt;span class="o"&gt;|&lt;/span&gt; Exec jump
        &lt;span class="o"&gt;|&lt;/span&gt; Jump &lt;span class="kt"&gt;vector&lt;/span&gt; &lt;span class="c1"&gt;#2                        |         | vector table&lt;/span&gt;
   &lt;span class="m"&gt;1030&lt;/span&gt; &lt;span class="o"&gt;+---------------------------------------+&lt;/span&gt; &lt;span class="mh"&gt;0x406&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt; Jump &lt;span class="kt"&gt;vector&lt;/span&gt; &lt;span class="c1"&gt;#1                        |         |&lt;/span&gt;
   &lt;span class="m"&gt;1024&lt;/span&gt; &lt;span class="o"&gt;+---------------------------------------+&lt;/span&gt; &lt;span class="mh"&gt;0x400&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-+&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt; End of reserved space                 &lt;span class="o"&gt;|&lt;/span&gt;         &lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="o"&gt;+---------------------------------------+&lt;/span&gt;         &lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kc"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;                                 &lt;span class="o"&gt;|&lt;/span&gt;         &lt;span class="o"&gt;|&lt;/span&gt;
     &lt;span class="m"&gt;12&lt;/span&gt; &lt;span class="o"&gt;+---------------------------------------+&lt;/span&gt; &lt;span class="mh"&gt;0xc&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt; Kilobyte
        &lt;span class="o"&gt;|&lt;/span&gt; Vector &lt;span class="c1"&gt;#2                             |         | reserved by&lt;/span&gt;
      &lt;span class="m"&gt;8&lt;/span&gt; &lt;span class="o"&gt;+---------------------------------------+&lt;/span&gt; &lt;span class="mh"&gt;0x8&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt; the M68k
        &lt;span class="o"&gt;|&lt;/span&gt; Reset Initial Program Counter         &lt;span class="o"&gt;|&lt;/span&gt;         &lt;span class="o"&gt;|&lt;/span&gt; architecture
      &lt;span class="m"&gt;4&lt;/span&gt; &lt;span class="o"&gt;+---------------------------------------+&lt;/span&gt; &lt;span class="mh"&gt;0x4&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt; Reset Initial Interrupt Stack Pointer &lt;span class="o"&gt;|&lt;/span&gt;         &lt;span class="o"&gt;|&lt;/span&gt;
      &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;+---------------------------------------+&lt;/span&gt; &lt;span class="mh"&gt;0x0&lt;/span&gt;   &lt;span class="o"&gt;&amp;lt;-+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Resources&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Microprocessor-based system design by Ricardo Gutierrez-Osuna (&lt;a href="http://courses.cs.tamu.edu/rgutier/ceg411_f01/"&gt;slides&lt;/a&gt;), in particular &lt;a href="http://courses.cs.tamu.edu/rgutier/ceg411_f01/l9.pdf"&gt;Lesson 9 - Exception processing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Motorola M68000 Family Programmer's Reference Manual &lt;a href="https://www.nxp.com/docs/en/reference-manual/M68000PRM.pdf"&gt;PDF here&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Amiga System Programmers Guide, Abacus (&lt;a href="https://archive.org/details/Amiga_System_Programmers_Guide_1988_Abacus"&gt;pdf here&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Feedback&lt;/h1&gt;
&lt;p&gt;Feel free to reach me on &lt;a href="https://twitter.com/thedigicat"&gt;Twitter&lt;/a&gt; if you have questions. The &lt;a href="http://github.com/TheDigitalCatOnline/thedigitalcatonline.github.com/issues"&gt;GitHub issues&lt;/a&gt; page is the best place to submit corrections.&lt;/p&gt;</content><category term="assembly"></category><category term="amiga"></category><category term="retroprogramming"></category></entry><entry><title>Exploring the Amiga - Part 5</title><link href="http://blog.thedigitalcatonline.com/blog/2018/06/25/exploring-the-amiga-5/" rel="alternate"></link><published>2018-06-25T12:00:00+01:00</published><updated>2018-06-25T12:00:00+01:00</updated><author><name>Leonardo Giordani</name></author><id>tag:blog.thedigitalcatonline.com,2018-06-25:/blog/2018/06/25/exploring-the-amiga-5/</id><summary type="html"></summary><content type="html">&lt;p&gt;Memory management is always one of the most rich and complex parts of an architecture, mainly because the available amount of memory is always less than what you would like to have. &lt;a href="https://users.ece.cmu.edu/~koopman/titan/rules.html"&gt;Always&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It is also an interesting topic because memory is generally managed by both the hardware and the software. The microprocessor may provide a memory management unit (MMU) that enforces a specific schema and the software has to implement its own algorithms on top of that.&lt;/p&gt;
&lt;p&gt;The Amiga originally run on a Motorola 68k, which doesn't provide any memory management in hardware. This means that there is no way for the processor to block attempts to read memory by a process, a feature that wasn't present on the first Intel x86 processors as well. Intel "solved" the issue with the introduction of the protected mode in the 386 family (even though an initial version was already present on the 286 processors). Motorola provided external MMUs for the 68010 and 68020, while the 68030 and later processor feature an on-chip MMU. &lt;/p&gt;
&lt;p&gt;The Motorola 68k is a 32-bit processor, thus registers and the address bus have that size. The memory, however, is connected to only 24 of the 32 lines of the bus, which means that the total memory space addressable by the processor is a 24-bit space, that gives 16 Megabytes instead of the possible 4 Gigabytes. That amount of memory was however enough for the period when the Amiga was designed. Consider that the most successful model of Amiga, the Amiga 500, had 500 KBytes of memory, sometimes increased to 1 Megabyte through a memory expansion.&lt;/p&gt;
&lt;p&gt;The lack of a memory scheme enforced by the processor means that at boot time the memory is just a flat area that can be addressed directly. As we saw in the previous instalments Exec creates its own structure in memory, generating the library node and creating the library jump table. This happens in the bigger picture of the machine initialisation, and one of the tasks performed during this initialisation is the setup of the memory management structures.&lt;/p&gt;
&lt;h1&gt;The Exec base address&lt;/h1&gt;
&lt;p&gt;Every Amiga programmer knows that address &lt;code&gt;0x4&lt;/code&gt; contains the Exec base address, and I showed in past instalments how this is used in conjunction with the jump table to call the library functions.&lt;/p&gt;
&lt;p&gt;The reason why the Exec base address is stored there is however seldom mentioned. As a matter of fact that address is not just a random choice.&lt;/p&gt;
&lt;p&gt;The Motorola 68000 family reserves the first Kilobyte of memory for exception vectors, that is code that will be executed when something wrong happens. "Wrong" here means bad at hardware level, from a divide by zero to a bus error. This is enforced by the Motorola 68k architecture and thus is a feature shared by other computers and consoles based on it.&lt;/p&gt;
&lt;p&gt;The first two of these vectors are actually used when the processor is powering-up (or in general when it resets). And the vector number 1 (the second) at offset &lt;code&gt;0x4&lt;/code&gt; is the Reset Initial Program Counter.&lt;/p&gt;
&lt;p&gt;After a reset the processor initialises the Program Counter with the address stored at &lt;code&gt;0x4&lt;/code&gt; in the memory. When the CPU is switched on, however, the Kickstart ROM is copied in memory, thus the addresses 0 and 4 (first two exception vectors) are the addresses listed in the ROM itself.&lt;/p&gt;
&lt;p&gt;The very first 8 bytes of the Kickstart ROM are&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;00000000:&lt;/span&gt; &lt;span class="mi"&gt;1111&lt;/span&gt;
&lt;span class="nl"&gt;00000002:&lt;/span&gt; &lt;span class="mi"&gt;4ef9&lt;/span&gt; &lt;span class="mi"&gt;00fc&lt;/span&gt; &lt;span class="mi"&gt;00d2&lt;/span&gt;            &lt;span class="k"&gt;jmp&lt;/span&gt;     &lt;span class="mi"&gt;0xfc00d2&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and you can clearly see that the long word at address &lt;code&gt;0x4&lt;/code&gt; is &lt;code&gt;00fc 00d2&lt;/code&gt;. This actually corresponds to the address where the initial code of the ROM is&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000000d2:&lt;/span&gt; &lt;span class="mi"&gt;4ff9&lt;/span&gt; &lt;span class="mi"&gt;0004&lt;/span&gt; &lt;span class="mi"&gt;0000&lt;/span&gt;            &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x40000&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;sp&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;which sets the stack pointer, but I'll keep this analysis for a future post.&lt;/p&gt;
&lt;p&gt;The address &lt;code&gt;0x4&lt;/code&gt; is then free to be used during the normal execution, since it is used only during a reset, but in that case whatever we wrote there (the Exec base address) is overwritten by the ROM code.&lt;/p&gt;
&lt;h1&gt;List headers&lt;/h1&gt;
&lt;p&gt;Exec manages memory and resources using &lt;a href="https://en.wikipedia.org/wiki/Linked_list"&gt;linked lists&lt;/a&gt;. As you know, to manage a linked list we need the address (pointer) of the head, of the tail, and also of the second-to-last element (the tail predecessor), to allow the tail to be detached and replaced. Actually it is evident that, given the convention that the last node is connected to the address 0, the only value we need is the address of the list head. The two additional addresses, however, can greatly simplify the code that manages the list and can greatly increase the performances, avoiding the need of a complete scan of the list to find the last element every time we want to add something to the end of the list.&lt;/p&gt;
&lt;p&gt;The Exec library provides a nice structure to manage lists, &lt;code&gt;LH&lt;/code&gt;. The structure is defined in &lt;code&gt;include_i/exec/lists.i&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;* Full featured list header&lt;/span&gt;
&lt;span class="c1"&gt;*&lt;/span&gt;
&lt;span class="c1"&gt;   STRUCTURE    LH,0&lt;/span&gt;
    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;LH_HEAD&lt;/span&gt;
    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;LH_TAIL&lt;/span&gt;
    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;LH_TAILPRED&lt;/span&gt;
    &lt;span class="n"&gt;UBYTE&lt;/span&gt;   &lt;span class="n"&gt;LH_TYPE&lt;/span&gt;
    &lt;span class="n"&gt;UBYTE&lt;/span&gt;   &lt;span class="n"&gt;LH_pad&lt;/span&gt;
    &lt;span class="n"&gt;LABEL&lt;/span&gt;   &lt;span class="n"&gt;LH_SIZE&lt;/span&gt; &lt;span class="c1"&gt;;word aligned&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The only two fields that this structure adds compared to the previous description are &lt;code&gt;LH_TYPE&lt;/code&gt;, that unsurprisingly contains the type of the data contained in the list, and &lt;code&gt;LH_pad&lt;/code&gt; which is nothing but what the name suggests, a padding that allows the structure to be word aligned.&lt;/p&gt;
&lt;p&gt;We need now to discover where Exec keeps the header for the memory list. Analysing the &lt;code&gt;ExecBase&lt;/code&gt; structure contained in &lt;code&gt;include_i/exec/execbase.i&lt;/code&gt; we find the following definitions&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;******* System List Headers (private!) ********************************&lt;/span&gt;

    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;MemList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;ResourceList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;DeviceList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IntrList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;LibList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;PortList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;TaskReady&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;TaskWait&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;SoftInts&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SH_SIZE&lt;/span&gt;&lt;span class="c1"&gt;*5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;which is exactly what we wanted. When Exec installs itself in the first part of the memory it will also initialise these headers to keep track of the corresponding resources.&lt;/p&gt;
&lt;p&gt;It is interesting to note, however, that the ExecBase structure described in the include files is not used directly, but is more a description of what the code is going to create. This is a bit different from what higher level languages like C use to do. In C you declare a structure, you reserve memory for it, and then access its fields. In Assembly, ultimately, there is no such a concept as a structure and a field. We have only a (flat) memory and addresses.&lt;/p&gt;
&lt;p&gt;Since ExecBase is a description of the structure of Exec once it will be installed in memory it is interesting to run through its fields and annotate the relative address of each of them.&lt;/p&gt;
&lt;p&gt;I took the code contained in &lt;code&gt;include_i/exec/execbase.i&lt;/code&gt; and I computed the address of each field. The first column contains the relative address inside the structure (thus starting from &lt;code&gt;0x0&lt;/code&gt;), while the second column contains the address relative to the Exec base address. As shown in the fourth post the &lt;code&gt;LN&lt;/code&gt; and &lt;code&gt;LIB&lt;/code&gt; structures fill the first 34 bytes, which is why the following starting address is &lt;code&gt;0x22&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;0000&lt;/span&gt; &lt;span class="mi"&gt;0022&lt;/span&gt;    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;SoftVer&lt;/span&gt; &lt;span class="c1"&gt;; kickstart release number (obs.)&lt;/span&gt;
&lt;span class="mi"&gt;0002&lt;/span&gt; &lt;span class="mi"&gt;0024&lt;/span&gt;    &lt;span class="n"&gt;WORD&lt;/span&gt;    &lt;span class="n"&gt;LowMemChkSum&lt;/span&gt;    &lt;span class="c1"&gt;; checksum of 68000 trap vectors&lt;/span&gt;
&lt;span class="mi"&gt;0004&lt;/span&gt; &lt;span class="mi"&gt;0026&lt;/span&gt;    &lt;span class="n"&gt;ULONG&lt;/span&gt;   &lt;span class="n"&gt;ChkBase&lt;/span&gt; &lt;span class="c1"&gt;; system base pointer complement&lt;/span&gt;
&lt;span class="mi"&gt;0008&lt;/span&gt; &lt;span class="mi"&gt;002a&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;ColdCapture&lt;/span&gt; &lt;span class="c1"&gt;; coldstart soft capture vector&lt;/span&gt;
&lt;span class="mi"&gt;000c&lt;/span&gt; &lt;span class="mi"&gt;002e&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;CoolCapture&lt;/span&gt; &lt;span class="c1"&gt;; coolstart soft capture vector&lt;/span&gt;
&lt;span class="mi"&gt;0010&lt;/span&gt; &lt;span class="mi"&gt;0032&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;WarmCapture&lt;/span&gt; &lt;span class="c1"&gt;; warmstart soft capture vector&lt;/span&gt;
&lt;span class="mi"&gt;0014&lt;/span&gt; &lt;span class="mi"&gt;0036&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;SysStkUpper&lt;/span&gt; &lt;span class="c1"&gt;; system stack base   (upper bound)&lt;/span&gt;
&lt;span class="mi"&gt;0018&lt;/span&gt; &lt;span class="mi"&gt;003a&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;SysStkLower&lt;/span&gt; &lt;span class="c1"&gt;; top of system stack (lower bound)&lt;/span&gt;
&lt;span class="mi"&gt;001c&lt;/span&gt; &lt;span class="mi"&gt;003e&lt;/span&gt;    &lt;span class="n"&gt;ULONG&lt;/span&gt;   &lt;span class="n"&gt;MaxLocMem&lt;/span&gt;   &lt;span class="c1"&gt;; top of chip memory&lt;/span&gt;
&lt;span class="mi"&gt;0020&lt;/span&gt; &lt;span class="mi"&gt;0042&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;DebugEntry&lt;/span&gt;  &lt;span class="c1"&gt;; global debugger entry point&lt;/span&gt;
&lt;span class="mi"&gt;0024&lt;/span&gt; &lt;span class="mi"&gt;0046&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;DebugData&lt;/span&gt;   &lt;span class="c1"&gt;; global debugger data segment&lt;/span&gt;
&lt;span class="mi"&gt;0028&lt;/span&gt; &lt;span class="mi"&gt;004a&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;AlertData&lt;/span&gt;   &lt;span class="c1"&gt;; alert data segment&lt;/span&gt;
&lt;span class="mi"&gt;002c&lt;/span&gt; &lt;span class="mi"&gt;004e&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;MaxExtMem&lt;/span&gt;   &lt;span class="c1"&gt;; top of extended mem, or null if none&lt;/span&gt;

&lt;span class="mi"&gt;0030&lt;/span&gt; &lt;span class="mi"&gt;0052&lt;/span&gt;    &lt;span class="n"&gt;WORD&lt;/span&gt;    &lt;span class="n"&gt;ChkSum&lt;/span&gt;      &lt;span class="c1"&gt;; for all of the above (minus 2)&lt;/span&gt;


&lt;span class="c1"&gt;******* Interrupt Related ********************************************&lt;/span&gt;

    &lt;span class="n"&gt;LABEL&lt;/span&gt;   &lt;span class="n"&gt;IntVects&lt;/span&gt;
&lt;span class="mi"&gt;0032&lt;/span&gt; &lt;span class="mi"&gt;0054&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVTBE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;003e&lt;/span&gt; &lt;span class="mi"&gt;0060&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVDSKBLK&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;004a&lt;/span&gt; &lt;span class="mi"&gt;006c&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVSOFTINT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;0056&lt;/span&gt; &lt;span class="mi"&gt;0078&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVPORTS&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;0062&lt;/span&gt; &lt;span class="mi"&gt;0084&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVCOPER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;006e&lt;/span&gt; &lt;span class="mi"&gt;0090&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVVERTB&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;007a&lt;/span&gt; &lt;span class="mi"&gt;009c&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVBLIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;0086&lt;/span&gt; &lt;span class="mi"&gt;00a8&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVAUD0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;0092&lt;/span&gt; &lt;span class="mi"&gt;00b4&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVAUD1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;009e&lt;/span&gt; &lt;span class="mi"&gt;00c0&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVAUD2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;00aa&lt;/span&gt; &lt;span class="mi"&gt;00cc&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVAUD3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;00b6&lt;/span&gt; &lt;span class="mi"&gt;00d8&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVRBF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;00c2&lt;/span&gt; &lt;span class="mi"&gt;00e4&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVDSKSYNC&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;00ce&lt;/span&gt; &lt;span class="mi"&gt;00f0&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVEXTER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;00da&lt;/span&gt; &lt;span class="mi"&gt;00fc&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVINTEN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;00e6&lt;/span&gt; &lt;span class="mi"&gt;0108&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IVNMI&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;IV_SIZE&lt;/span&gt;


&lt;span class="c1"&gt;******* Dynamic System Variables *************************************&lt;/span&gt;

&lt;span class="mi"&gt;00f2&lt;/span&gt; &lt;span class="mi"&gt;0114&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;ThisTask&lt;/span&gt;    &lt;span class="c1"&gt;; pointer to current task (readable)&lt;/span&gt;

&lt;span class="mi"&gt;00f6&lt;/span&gt; &lt;span class="mi"&gt;0118&lt;/span&gt;    &lt;span class="n"&gt;ULONG&lt;/span&gt;   &lt;span class="n"&gt;IdleCount&lt;/span&gt;   &lt;span class="c1"&gt;; idle counter&lt;/span&gt;
&lt;span class="mi"&gt;00fa&lt;/span&gt; &lt;span class="mi"&gt;011c&lt;/span&gt;    &lt;span class="n"&gt;ULONG&lt;/span&gt;   &lt;span class="n"&gt;DispCount&lt;/span&gt;   &lt;span class="c1"&gt;; dispatch counter&lt;/span&gt;
&lt;span class="mi"&gt;00fe&lt;/span&gt; &lt;span class="mi"&gt;0120&lt;/span&gt;    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;Quantum&lt;/span&gt; &lt;span class="c1"&gt;; time slice quantum&lt;/span&gt;
&lt;span class="mi"&gt;0100&lt;/span&gt; &lt;span class="mi"&gt;0122&lt;/span&gt;    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;Elapsed&lt;/span&gt; &lt;span class="c1"&gt;; current quantum ticks&lt;/span&gt;
&lt;span class="mi"&gt;0102&lt;/span&gt; &lt;span class="mi"&gt;0124&lt;/span&gt;    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;SysFlags&lt;/span&gt;    &lt;span class="c1"&gt;; misc internal system flags&lt;/span&gt;
&lt;span class="mi"&gt;0104&lt;/span&gt; &lt;span class="mi"&gt;0126&lt;/span&gt;    &lt;span class="n"&gt;BYTE&lt;/span&gt;    &lt;span class="n"&gt;IDNestCnt&lt;/span&gt;   &lt;span class="c1"&gt;; interrupt disable nesting count&lt;/span&gt;
&lt;span class="mi"&gt;0105&lt;/span&gt; &lt;span class="mi"&gt;0127&lt;/span&gt;    &lt;span class="n"&gt;BYTE&lt;/span&gt;    &lt;span class="n"&gt;TDNestCnt&lt;/span&gt;   &lt;span class="c1"&gt;; task disable nesting count&lt;/span&gt;

&lt;span class="mi"&gt;0106&lt;/span&gt; &lt;span class="mi"&gt;0128&lt;/span&gt;    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;AttnFlags&lt;/span&gt;   &lt;span class="c1"&gt;; special attention flags (readable)&lt;/span&gt;

&lt;span class="mi"&gt;0108&lt;/span&gt; &lt;span class="mi"&gt;012a&lt;/span&gt;    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;AttnResched&lt;/span&gt; &lt;span class="c1"&gt;; rescheduling attention&lt;/span&gt;
&lt;span class="mi"&gt;010a&lt;/span&gt; &lt;span class="mi"&gt;012c&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;ResModules&lt;/span&gt;  &lt;span class="c1"&gt;; pointer to resident module array&lt;/span&gt;
&lt;span class="mi"&gt;010e&lt;/span&gt; &lt;span class="mi"&gt;0130&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;TaskTrapCode&lt;/span&gt;    &lt;span class="c1"&gt;; default task trap routine&lt;/span&gt;
&lt;span class="mi"&gt;0112&lt;/span&gt; &lt;span class="mi"&gt;0134&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;TaskExceptCode&lt;/span&gt;  &lt;span class="c1"&gt;; default task exception code&lt;/span&gt;
&lt;span class="mi"&gt;0116&lt;/span&gt; &lt;span class="mi"&gt;0138&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;TaskExitCode&lt;/span&gt;    &lt;span class="c1"&gt;; default task exit code&lt;/span&gt;
&lt;span class="mi"&gt;011a&lt;/span&gt; &lt;span class="mi"&gt;013c&lt;/span&gt;    &lt;span class="n"&gt;ULONG&lt;/span&gt;   &lt;span class="n"&gt;TaskSigAlloc&lt;/span&gt;    &lt;span class="c1"&gt;; preallocated signal mask&lt;/span&gt;
&lt;span class="mi"&gt;011e&lt;/span&gt; &lt;span class="mi"&gt;0140&lt;/span&gt;    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;TaskTrapAlloc&lt;/span&gt;   &lt;span class="c1"&gt;; preallocated trap mask&lt;/span&gt;


&lt;span class="c1"&gt;******* System List Headers (private!) ********************************&lt;/span&gt;

&lt;span class="mi"&gt;0120&lt;/span&gt; &lt;span class="mi"&gt;0142&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;MemList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;012e&lt;/span&gt; &lt;span class="mi"&gt;0150&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;ResourceList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;013c&lt;/span&gt; &lt;span class="mi"&gt;015e&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;DeviceList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;014a&lt;/span&gt; &lt;span class="mi"&gt;016c&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;IntrList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;0158&lt;/span&gt; &lt;span class="mi"&gt;017a&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;LibList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;0166&lt;/span&gt; &lt;span class="mi"&gt;0188&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;PortList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;0174&lt;/span&gt; &lt;span class="mi"&gt;0196&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;TaskReady&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;0182&lt;/span&gt; &lt;span class="mi"&gt;01a4&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;TaskWait&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;
&lt;span class="mi"&gt;0190&lt;/span&gt; &lt;span class="mi"&gt;01b2&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;SoftInts&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SH_SIZE&lt;/span&gt;&lt;span class="c1"&gt;*5&lt;/span&gt;

&lt;span class="mi"&gt;01e0&lt;/span&gt; &lt;span class="mi"&gt;0202&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;LastAlert&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="c1"&gt;*4&lt;/span&gt;

&lt;span class="mi"&gt;01f0&lt;/span&gt; &lt;span class="mi"&gt;0212&lt;/span&gt;    &lt;span class="n"&gt;UBYTE&lt;/span&gt;   &lt;span class="n"&gt;VBlankFrequency&lt;/span&gt;     &lt;span class="c1"&gt;;(readable)&lt;/span&gt;
&lt;span class="mi"&gt;01f1&lt;/span&gt; &lt;span class="mi"&gt;0213&lt;/span&gt;    &lt;span class="n"&gt;UBYTE&lt;/span&gt;   &lt;span class="n"&gt;PowerSupplyFrequency&lt;/span&gt;    &lt;span class="c1"&gt;;(readable)&lt;/span&gt;

&lt;span class="mi"&gt;01f2&lt;/span&gt; &lt;span class="mi"&gt;0214&lt;/span&gt;    &lt;span class="n"&gt;STRUCT&lt;/span&gt;  &lt;span class="n"&gt;SemaphoreList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LH_SIZE&lt;/span&gt;

&lt;span class="mi"&gt;0200&lt;/span&gt; &lt;span class="mi"&gt;0222&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;KickMemPtr&lt;/span&gt;  &lt;span class="c1"&gt;; ptr to queue of mem lists&lt;/span&gt;
&lt;span class="mi"&gt;0204&lt;/span&gt; &lt;span class="mi"&gt;0226&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;KickTagPtr&lt;/span&gt;  &lt;span class="c1"&gt;; ptr to rom tag queue&lt;/span&gt;
&lt;span class="mi"&gt;0208&lt;/span&gt; &lt;span class="mi"&gt;022a&lt;/span&gt;    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;KickCheckSum&lt;/span&gt;    &lt;span class="c1"&gt;; checksum for mem and tags&lt;/span&gt;

&lt;span class="mi"&gt;020c&lt;/span&gt; &lt;span class="mi"&gt;022e&lt;/span&gt;    &lt;span class="n"&gt;UBYTE&lt;/span&gt; &lt;span class="n"&gt;ExecBaseReserved&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
&lt;span class="mi"&gt;0216&lt;/span&gt; &lt;span class="mi"&gt;0238&lt;/span&gt;    &lt;span class="n"&gt;UBYTE&lt;/span&gt; &lt;span class="n"&gt;ExecBaseNewReserved&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
&lt;span class="mi"&gt;022a&lt;/span&gt; &lt;span class="mi"&gt;024c&lt;/span&gt;    &lt;span class="n"&gt;LABEL&lt;/span&gt;   &lt;span class="n"&gt;SYSBASESIZE&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;According to this structure we expect to find the memory list header 322 bytes (&lt;code&gt;0x142&lt;/code&gt;) after the base address, which means that this number should be mentioned somewhere in the Kickstart code.&lt;/p&gt;
&lt;p&gt;It is not surprise indeed that the function &lt;code&gt;AllocMem&lt;/code&gt; mentions it. This function is part of the Exec API that we explored in the third and fourth instalments. Following the same method described there I found the function at the address &lt;code&gt;0x17d0&lt;/code&gt; in the Kickstart code&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;; memoryBlock = AllocMem(byteSize, attributes)&lt;/span&gt;
&lt;span class="c1"&gt;; d0                     d0        d1&lt;/span&gt;

&lt;span class="nl"&gt;000017d0:&lt;/span&gt; &lt;span class="mi"&gt;522e&lt;/span&gt; &lt;span class="mi"&gt;0127&lt;/span&gt;                 &lt;span class="k"&gt;addq&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;  &lt;span class="nl"&gt;#0x1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0x127&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000017d4:&lt;/span&gt; &lt;span class="mi"&gt;48e7&lt;/span&gt; &lt;span class="mi"&gt;3020&lt;/span&gt;                 &lt;span class="k"&gt;movem&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt; &lt;span class="o"&gt;d2&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="o"&gt;d3&lt;/span&gt;&lt;span class="p"&gt;/&lt;/span&gt;&lt;span class="o"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,-(&lt;/span&gt;&lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000017d8:&lt;/span&gt; &lt;span class="mi"&gt;2600&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d3&lt;/span&gt;
&lt;span class="nl"&gt;000017da:&lt;/span&gt; &lt;span class="mi"&gt;2401&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;d1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d2&lt;/span&gt;
&lt;span class="nl"&gt;000017dc:&lt;/span&gt; &lt;span class="mi"&gt;45ee&lt;/span&gt; &lt;span class="mi"&gt;0142&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x142&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a2&lt;/span&gt;
&lt;span class="nl"&gt;000017e0:&lt;/span&gt; &lt;span class="mi"&gt;2452&lt;/span&gt;                      &lt;span class="k"&gt;movea&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a2&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and in this initial part of the function we can clearly see the code that loads the effective address of &lt;code&gt;0x142(a6)&lt;/code&gt;. Remember that &lt;code&gt;a6&lt;/code&gt; is always supposed to contain the Exec base address.&lt;/p&gt;
&lt;p&gt;The displacement &lt;code&gt;0x142&lt;/code&gt; is also mentioned in a table towards the beginning of the code, and this is the part we are really interested in at the moment&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;; Initialise list headers&lt;/span&gt;

&lt;span class="nl"&gt;000002b0:&lt;/span&gt; &lt;span class="mi"&gt;43fa&lt;/span&gt; &lt;span class="mi"&gt;0020&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x2d2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;
&lt;span class="nl"&gt;000002b4:&lt;/span&gt; &lt;span class="mi"&gt;3019&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)+,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000002b6:&lt;/span&gt; &lt;span class="mi"&gt;6700&lt;/span&gt; &lt;span class="mi"&gt;0086&lt;/span&gt;                 &lt;span class="k"&gt;beq&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;   &lt;span class="mi"&gt;0x33e&lt;/span&gt;
&lt;span class="nl"&gt;000002ba:&lt;/span&gt; &lt;span class="mi"&gt;41f6&lt;/span&gt; &lt;span class="mi"&gt;0000&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0.w&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;
&lt;span class="nl"&gt;000002be:&lt;/span&gt; &lt;span class="mi"&gt;2088&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000002c0:&lt;/span&gt; &lt;span class="mi"&gt;5890&lt;/span&gt;                      &lt;span class="k"&gt;addq&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="nl"&gt;#0x4&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000002c2:&lt;/span&gt; &lt;span class="mi"&gt;42a8&lt;/span&gt; &lt;span class="mi"&gt;0004&lt;/span&gt;                 &lt;span class="k"&gt;clr&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;   &lt;span class="mi"&gt;0x4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000002c6:&lt;/span&gt; &lt;span class="mi"&gt;2148&lt;/span&gt; &lt;span class="mi"&gt;0008&lt;/span&gt;                 &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0x8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000002ca:&lt;/span&gt; &lt;span class="mi"&gt;3019&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)+,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000002cc:&lt;/span&gt; &lt;span class="mi"&gt;1140&lt;/span&gt; &lt;span class="mi"&gt;000c&lt;/span&gt;                 &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;  &lt;span class="o"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0xc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000002d0:&lt;/span&gt; &lt;span class="mi"&gt;60e2&lt;/span&gt;                      &lt;span class="k"&gt;bra&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="mi"&gt;0x2b4&lt;/span&gt;

&lt;span class="c1"&gt;; List headers&lt;/span&gt;

&lt;span class="nl"&gt;000002d2:&lt;/span&gt; &lt;span class="mi"&gt;0142&lt;/span&gt; &lt;span class="mi"&gt;000a&lt;/span&gt;
&lt;span class="nl"&gt;000002d6:&lt;/span&gt; &lt;span class="mi"&gt;0150&lt;/span&gt; &lt;span class="mi"&gt;0008&lt;/span&gt;
&lt;span class="nl"&gt;000002da:&lt;/span&gt; &lt;span class="mi"&gt;015e&lt;/span&gt; &lt;span class="mi"&gt;0003&lt;/span&gt;
&lt;span class="nl"&gt;000002de:&lt;/span&gt; &lt;span class="mi"&gt;017a&lt;/span&gt; &lt;span class="mi"&gt;0009&lt;/span&gt;
&lt;span class="nl"&gt;000002e2:&lt;/span&gt; &lt;span class="mi"&gt;0188&lt;/span&gt; &lt;span class="mi"&gt;0004&lt;/span&gt;
&lt;span class="nl"&gt;000002e6:&lt;/span&gt; &lt;span class="mi"&gt;0196&lt;/span&gt; &lt;span class="mi"&gt;0001&lt;/span&gt;
&lt;span class="nl"&gt;000002ea:&lt;/span&gt; &lt;span class="mi"&gt;01a4&lt;/span&gt; &lt;span class="mi"&gt;0001&lt;/span&gt;
&lt;span class="nl"&gt;000002ee:&lt;/span&gt; &lt;span class="mi"&gt;016c&lt;/span&gt; &lt;span class="mi"&gt;0002&lt;/span&gt;
&lt;span class="nl"&gt;000002f2:&lt;/span&gt; &lt;span class="mi"&gt;01b2&lt;/span&gt; &lt;span class="mi"&gt;000b&lt;/span&gt;
&lt;span class="nl"&gt;000002f6:&lt;/span&gt; &lt;span class="mi"&gt;01c2&lt;/span&gt; &lt;span class="mi"&gt;000b&lt;/span&gt;
&lt;span class="nl"&gt;000002fa:&lt;/span&gt; &lt;span class="mi"&gt;01d2&lt;/span&gt; &lt;span class="mi"&gt;000b&lt;/span&gt;
&lt;span class="nl"&gt;000002fe:&lt;/span&gt; &lt;span class="mi"&gt;01e2&lt;/span&gt; &lt;span class="mi"&gt;000b&lt;/span&gt;
&lt;span class="nl"&gt;00000302:&lt;/span&gt; &lt;span class="mi"&gt;01f2&lt;/span&gt; &lt;span class="mi"&gt;000b&lt;/span&gt;
&lt;span class="nl"&gt;00000306:&lt;/span&gt; &lt;span class="mi"&gt;0214&lt;/span&gt; &lt;span class="mi"&gt;000f&lt;/span&gt;
&lt;span class="nl"&gt;0000030a:&lt;/span&gt; &lt;span class="mi"&gt;0000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see I formatted the code to show that the values after &lt;code&gt;02d2&lt;/code&gt; are data and not code. The disassembler will obviously show you some instructions but they are just misinterpretations of the binary data.&lt;/p&gt;
&lt;p&gt;This table is immediately followed by the table we found in the third post, when we were looking at the values of the &lt;code&gt;LIB&lt;/code&gt; structure.&lt;/p&gt;
&lt;p&gt;Let's comment line by line the code at &lt;code&gt;02b0&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;; Initialise list headers&lt;/span&gt;

&lt;span class="nl"&gt;000002b0:&lt;/span&gt; &lt;span class="mi"&gt;43fa&lt;/span&gt; &lt;span class="mi"&gt;0020&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x2d2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;
&lt;span class="nl"&gt;000002b4:&lt;/span&gt; &lt;span class="mi"&gt;3019&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)+,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000002b6:&lt;/span&gt; &lt;span class="mi"&gt;6700&lt;/span&gt; &lt;span class="mi"&gt;0086&lt;/span&gt;                 &lt;span class="k"&gt;beq&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;   &lt;span class="mi"&gt;0x33e&lt;/span&gt;
&lt;span class="nl"&gt;000002ba:&lt;/span&gt; &lt;span class="mi"&gt;41f6&lt;/span&gt; &lt;span class="mi"&gt;0000&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0.w&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;
&lt;span class="nl"&gt;000002be:&lt;/span&gt; &lt;span class="mi"&gt;2088&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000002c0:&lt;/span&gt; &lt;span class="mi"&gt;5890&lt;/span&gt;                      &lt;span class="k"&gt;addq&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="nl"&gt;#0x4&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000002c2:&lt;/span&gt; &lt;span class="mi"&gt;42a8&lt;/span&gt; &lt;span class="mi"&gt;0004&lt;/span&gt;                 &lt;span class="k"&gt;clr&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;   &lt;span class="mi"&gt;0x4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000002c6:&lt;/span&gt; &lt;span class="mi"&gt;2148&lt;/span&gt; &lt;span class="mi"&gt;0008&lt;/span&gt;                 &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0x8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000002ca:&lt;/span&gt; &lt;span class="mi"&gt;3019&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)+,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000002cc:&lt;/span&gt; &lt;span class="mi"&gt;1140&lt;/span&gt; &lt;span class="mi"&gt;000c&lt;/span&gt;                 &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;  &lt;span class="o"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0xc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000002d0:&lt;/span&gt; &lt;span class="mi"&gt;60e2&lt;/span&gt;                      &lt;span class="k"&gt;bra&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="mi"&gt;0x2b4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000002b0:&lt;/span&gt; &lt;span class="mi"&gt;43fa&lt;/span&gt; &lt;span class="mi"&gt;0020&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x2d2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;First of all the code loads the absolute address of &lt;code&gt;0x2d2(pc)&lt;/code&gt; in the &lt;code&gt;a1&lt;/code&gt; register. This is exactly the beginning of the table, as shown above.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000002b4:&lt;/span&gt; &lt;span class="mi"&gt;3019&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)+,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000002b6:&lt;/span&gt; &lt;span class="mi"&gt;6700&lt;/span&gt; &lt;span class="mi"&gt;0086&lt;/span&gt;                 &lt;span class="k"&gt;beq&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;   &lt;span class="mi"&gt;0x33e&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The code then loads the first value of the table (&lt;code&gt;0142&lt;/code&gt;) in &lt;code&gt;d0&lt;/code&gt; and increments &lt;code&gt;a1&lt;/code&gt;. This suggests that we are looking at a loop. The following instruction is indeed a comparison that jumps to &lt;code&gt;0x33e&lt;/code&gt; is the value is &lt;code&gt;0&lt;/code&gt;. You can easily see above that the table is terminated by a &lt;code&gt;0000&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000002ba:&lt;/span&gt; &lt;span class="mi"&gt;41f6&lt;/span&gt; &lt;span class="mi"&gt;0000&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0.w&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The register &lt;code&gt;a0&lt;/code&gt; is then loaded with the effective address of Exec + &lt;code&gt;d0&lt;/code&gt;. This means that we use the value we just read from the table as a pointer. For the first value, then, we are looking at &lt;code&gt;0x142&lt;/code&gt; bytes after the beginning of the Exec library, exactly where we expected to find the Memory List header.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000002be:&lt;/span&gt; &lt;span class="mi"&gt;2088&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000002c0:&lt;/span&gt; &lt;span class="mi"&gt;5890&lt;/span&gt;                      &lt;span class="k"&gt;addq&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="nl"&gt;#0x4&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;An empty linked list has the head pointing to the tail and the tail pointing to zero. To do this we set the content of that address &lt;code&gt;(a0)&lt;/code&gt; to the address itself (&lt;code&gt;a0&lt;/code&gt;), then we increment it by 4 making it point to the tail.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000002c2:&lt;/span&gt; &lt;span class="mi"&gt;42a8&lt;/span&gt; &lt;span class="mi"&gt;0004&lt;/span&gt;                 &lt;span class="k"&gt;clr&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;   &lt;span class="mi"&gt;0x4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000002c6:&lt;/span&gt; &lt;span class="mi"&gt;2148&lt;/span&gt; &lt;span class="mi"&gt;0008&lt;/span&gt;                 &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0x8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The tail itself is then cleared and the tail predecessor is set to be the head.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000002ca:&lt;/span&gt; &lt;span class="mi"&gt;3019&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)+,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000002cc:&lt;/span&gt; &lt;span class="mi"&gt;1140&lt;/span&gt; &lt;span class="mi"&gt;000c&lt;/span&gt;                 &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;  &lt;span class="o"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0xc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The code then fetches the next word from the table (&lt;code&gt;000a&lt;/code&gt;) and puts it into a field 12 bytes (&lt;code&gt;0xc&lt;/code&gt;) from the beginning of the structure, that is &lt;code&gt;LH_TYPE&lt;/code&gt;. The possible values of this byte can be found in &lt;code&gt;include_i/exec/nodes.i&lt;/code&gt;, where we find that the value &lt;code&gt;0xa&lt;/code&gt; corresponds to &lt;code&gt;NT_MEMORY&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;------ Node Types for LN_TYPE&lt;/span&gt;

&lt;span class="n"&gt;NT_UNKNOWN&lt;/span&gt;  &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;NT_TASK&lt;/span&gt; &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="c1"&gt;; Exec task&lt;/span&gt;
&lt;span class="n"&gt;NT_INTERRUPT&lt;/span&gt;    &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="n"&gt;NT_DEVICE&lt;/span&gt;   &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="n"&gt;NT_MSGPORT&lt;/span&gt;  &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="n"&gt;NT_MESSAGE&lt;/span&gt;  &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="c1"&gt;; Indicates message currently pending&lt;/span&gt;
&lt;span class="n"&gt;NT_FREEMSG&lt;/span&gt;  &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="n"&gt;NT_REPLYMSG&lt;/span&gt; &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="c1"&gt;; Message has been replied&lt;/span&gt;
&lt;span class="n"&gt;NT_RESOURCE&lt;/span&gt; &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="n"&gt;NT_LIBRARY&lt;/span&gt;  &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;
&lt;span class="n"&gt;NT_MEMORY&lt;/span&gt;   &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="n"&gt;NT_SOFTINT&lt;/span&gt;  &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;  &lt;span class="c1"&gt;; Internal flag used by SoftInts&lt;/span&gt;
&lt;span class="n"&gt;NT_FONT&lt;/span&gt; &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;
&lt;span class="n"&gt;NT_PROCESS&lt;/span&gt;  &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;  &lt;span class="c1"&gt;; AmigaDOS Process&lt;/span&gt;
&lt;span class="n"&gt;NT_SEMAPHORE&lt;/span&gt;    &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt;
&lt;span class="n"&gt;NT_SIGNALSEM&lt;/span&gt;    &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;  &lt;span class="c1"&gt;; signal semaphores&lt;/span&gt;
&lt;span class="n"&gt;NT_BOOTNODE&lt;/span&gt; &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;
&lt;span class="n"&gt;NT_KICKMEM&lt;/span&gt;  &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;17&lt;/span&gt;
&lt;span class="n"&gt;NT_GRAPHICS&lt;/span&gt; &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;18&lt;/span&gt;
&lt;span class="n"&gt;NT_DEATHMESSAGE&lt;/span&gt; &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;

&lt;span class="n"&gt;NT_USER&lt;/span&gt;     &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;254&lt;/span&gt; &lt;span class="c1"&gt;; User node types work down from here&lt;/span&gt;
&lt;span class="n"&gt;NT_EXTENDED&lt;/span&gt; &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;255&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;There is only one instruction left&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000002d0:&lt;/span&gt; &lt;span class="mi"&gt;60e2&lt;/span&gt;                      &lt;span class="k"&gt;bra&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="mi"&gt;0x2b4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;which jumps back to the beginning of this short piece of code. The procedure then keeps looping on the whole table until it reaches the list terminator &lt;code&gt;0000&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The final content of the memory at &lt;code&gt;0142&lt;/code&gt; will be&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;00000142:&lt;/span&gt; &lt;span class="mi"&gt;0000&lt;/span&gt; &lt;span class="mi"&gt;0146&lt;/span&gt; &lt;span class="c1"&gt;; LH_HEAD&lt;/span&gt;
&lt;span class="nl"&gt;00000146:&lt;/span&gt; &lt;span class="mi"&gt;0000&lt;/span&gt; &lt;span class="mi"&gt;0000&lt;/span&gt; &lt;span class="c1"&gt;; LH_TAIL&lt;/span&gt;
&lt;span class="nl"&gt;0000014a:&lt;/span&gt; &lt;span class="mi"&gt;0000&lt;/span&gt; &lt;span class="mi"&gt;0146&lt;/span&gt; &lt;span class="c1"&gt;; LH_TAILPRED&lt;/span&gt;
&lt;span class="nl"&gt;0000014d:&lt;/span&gt; &lt;span class="mi"&gt;0a&lt;/span&gt;        &lt;span class="c1"&gt;; LH_TYPE&lt;/span&gt;
&lt;span class="nl"&gt;0000014e:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And the same happens for the remaining 7 lists from &lt;code&gt;ResourceList&lt;/code&gt; to &lt;code&gt;TaskWait&lt;/code&gt;. After this the Exec lists are initialised.&lt;/p&gt;
&lt;h1&gt;Resources&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Microprocessor-based system design by Ricardo Gutierrez-Osuna (&lt;a href="http://courses.cs.tamu.edu/rgutier/ceg411_f01/"&gt;slides&lt;/a&gt;), in particular &lt;a href="http://courses.cs.tamu.edu/rgutier/ceg411_f01/l9.pdf"&gt;Lesson 9 - Exception processing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Motorola M68000 Family Programmer's Reference Manual &lt;a href="https://www.nxp.com/docs/en/reference-manual/M68000PRM.pdf"&gt;PDF here&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Feedback&lt;/h1&gt;
&lt;p&gt;Feel free to reach me on &lt;a href="https://twitter.com/thedigicat"&gt;Twitter&lt;/a&gt; if you have questions. The &lt;a href="http://github.com/TheDigitalCatOnline/thedigitalcatonline.github.com/issues"&gt;GitHub issues&lt;/a&gt; page is the best place to submit corrections.&lt;/p&gt;</content><category term="assembly"></category><category term="amiga"></category><category term="retroprogramming"></category></entry><entry><title>Exploring the Amiga - Part 4</title><link href="http://blog.thedigitalcatonline.com/blog/2018/06/14/exploring-the-amiga-4/" rel="alternate"></link><published>2018-06-14T14:30:00+01:00</published><updated>2018-06-14T14:30:00+01:00</updated><author><name>Leonardo Giordani</name></author><id>tag:blog.thedigitalcatonline.com,2018-06-14:/blog/2018/06/14/exploring-the-amiga-4/</id><summary type="html"></summary><content type="html">&lt;h1&gt;The Exec base functions&lt;/h1&gt;
&lt;p&gt;We found the Kickstart 1.3 (&lt;code&gt;exec&lt;/code&gt; 34.2) vector table at address &lt;code&gt;0x1a7c&lt;/code&gt;, and the first 4 entries read&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;00001a7c:&lt;/span&gt; &lt;span class="mi"&gt;08a0&lt;/span&gt;
&lt;span class="nl"&gt;00001a7e:&lt;/span&gt; &lt;span class="mi"&gt;08a8&lt;/span&gt;
&lt;span class="nl"&gt;00001a80:&lt;/span&gt; &lt;span class="mi"&gt;08ac&lt;/span&gt;
&lt;span class="nl"&gt;00001a82:&lt;/span&gt; &lt;span class="mi"&gt;08ac&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If we translate these relative values into absolute addresses, summing the address of the table itself, we discover the address of the 4 base functions that every Amiga library has to provide, namely &lt;code&gt;Open&lt;/code&gt;, &lt;code&gt;Close&lt;/code&gt;, &lt;code&gt;Expunge&lt;/code&gt;, and a reserved slot that should contain a function that returns 0.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;Open&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;The first value is &lt;code&gt;0x08a0&lt;/code&gt;, and if we sum this value to the address of the table itself we get &lt;code&gt;0x1a7c + 0x08a0 = 0x231c&lt;/code&gt;. At this address we will find the first function defined in the jump table, that is &lt;code&gt;Open&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The code is the following&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;; Open&lt;/span&gt;

&lt;span class="nl"&gt;0000231c:&lt;/span&gt; &lt;span class="mi"&gt;200e&lt;/span&gt;      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;0000231e:&lt;/span&gt; &lt;span class="mi"&gt;526e&lt;/span&gt; &lt;span class="mi"&gt;0020&lt;/span&gt; &lt;span class="k"&gt;addq&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="nl"&gt;#0x1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0x20&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;00002322:&lt;/span&gt; &lt;span class="mi"&gt;4e75&lt;/span&gt;      &lt;span class="k"&gt;rts&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;Open&lt;/code&gt; routine expects the address of the library to be in the &lt;code&gt;a6&lt;/code&gt; register, and returns the same value in &lt;code&gt;d0&lt;/code&gt;. It then adds 1 to the number contained 32 bytes (&lt;code&gt;0x20&lt;/code&gt;) after the address of the library itself and then returns. To find out what this number is we can go back again to the NDK and its include files.&lt;/p&gt;
&lt;p&gt;From a previous investigation we know that, once the library has been installed in memory, there are two structures defined one after the other. The first is the &lt;code&gt;LN&lt;/code&gt; structure that represents a linked list node, and the second is the &lt;code&gt;LIB&lt;/code&gt; structure that represents the library.&lt;/p&gt;
&lt;p&gt;We find the definition of &lt;code&gt;LN&lt;/code&gt; in &lt;code&gt;include_i/exec/nodes.i&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="n"&gt;STRUCTURE&lt;/span&gt;    &lt;span class="n"&gt;LN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="c1"&gt;; List Node&lt;/span&gt;
    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;LN_SUCC&lt;/span&gt; &lt;span class="c1"&gt;; Pointer to next (successor)&lt;/span&gt;
    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;LN_PRED&lt;/span&gt; &lt;span class="c1"&gt;; Pointer to previous (predecessor)&lt;/span&gt;
    &lt;span class="n"&gt;UBYTE&lt;/span&gt;   &lt;span class="n"&gt;LN_TYPE&lt;/span&gt;
    &lt;span class="n"&gt;BYTE&lt;/span&gt;    &lt;span class="n"&gt;LN_PRI&lt;/span&gt;  &lt;span class="c1"&gt;; Priority, for sorting&lt;/span&gt;
    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;LN_NAME&lt;/span&gt; &lt;span class="c1"&gt;; ID string, null terminated&lt;/span&gt;
    &lt;span class="n"&gt;LABEL&lt;/span&gt;   &lt;span class="n"&gt;LN_SIZE&lt;/span&gt; &lt;span class="c1"&gt;; Note: word aligned&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and the definition of &lt;code&gt;LIB&lt;/code&gt; in &lt;code&gt;include_i/exewc/libraries.i&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="n"&gt;STRUCTURE&lt;/span&gt; &lt;span class="n"&gt;LIB&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LN_SIZE&lt;/span&gt;
    &lt;span class="n"&gt;UBYTE&lt;/span&gt;   &lt;span class="n"&gt;LIB_FLAGS&lt;/span&gt;           &lt;span class="c1"&gt;; see below&lt;/span&gt;
    &lt;span class="n"&gt;UBYTE&lt;/span&gt;   &lt;span class="n"&gt;LIB_pad&lt;/span&gt;         &lt;span class="c1"&gt;; must be zero&lt;/span&gt;
    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;LIB_NEGSIZE&lt;/span&gt;     &lt;span class="c1"&gt;; number of bytes before LIB&lt;/span&gt;
    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;LIB_POSSIZE&lt;/span&gt;     &lt;span class="c1"&gt;; number of bytes after LIB&lt;/span&gt;
    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;LIB_VERSION&lt;/span&gt;     &lt;span class="c1"&gt;; major&lt;/span&gt;
    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;LIB_REVISION&lt;/span&gt;        &lt;span class="c1"&gt;; minor&lt;/span&gt;
    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;LIB_IDSTRING&lt;/span&gt;        &lt;span class="c1"&gt;; ASCII identification&lt;/span&gt;
    &lt;span class="n"&gt;ULONG&lt;/span&gt;   &lt;span class="n"&gt;LIB_SUM&lt;/span&gt;         &lt;span class="c1"&gt;; the system-calculated checksum&lt;/span&gt;
    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;LIB_OPENCNT&lt;/span&gt;     &lt;span class="c1"&gt;; number of current opens&lt;/span&gt;
    &lt;span class="n"&gt;LABEL&lt;/span&gt;   &lt;span class="n"&gt;LIB_SIZE&lt;/span&gt;    &lt;span class="c1"&gt;;Warning: Size is not a longword multiple!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see this latter mentions the former reserving space for it at the beginning (&lt;code&gt;LN_SIZE&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LABEL&lt;/code&gt; is a macro that creates an alias for the current size of the structure, and you can find its definition in &lt;code&gt;include_i/exec/types.i&lt;/code&gt;. It works in conjunction with the type macros, which increment the global variable &lt;code&gt;SOFFSET&lt;/code&gt;. The code &lt;code&gt;LABEL LN_SIZE&lt;/code&gt; in the &lt;code&gt;LN&lt;/code&gt; structure produces the definition &lt;code&gt;LN_SIZE EQU 14&lt;/code&gt;, which is thus a simple marker and does not contribute to the size of the structure itself.&lt;/p&gt;
&lt;p&gt;The comment after the &lt;code&gt;LABEL&lt;/code&gt; macro in the &lt;code&gt;LN&lt;/code&gt; structure says that the structure is word aligned, and indeed its size is a multiple of a word (2 bytes): 2 &lt;code&gt;APTR&lt;/code&gt; (8 bytes) + 1 &lt;code&gt;UBYTE&lt;/code&gt; (1 byte) + 1 &lt;code&gt;BYTE&lt;/code&gt; (1 byte) + 1 &lt;code&gt;APTR&lt;/code&gt; (4 byte) = 14 bytes.&lt;/p&gt;
&lt;p&gt;To find the field updated by &lt;code&gt;Open&lt;/code&gt; we need to skip 32 bytes. So, after we skip the whole &lt;code&gt;LN&lt;/code&gt; structure, we still have 18 bytes to skip into the &lt;code&gt;LIB&lt;/code&gt; structure. At that offset we find the &lt;code&gt;LIB_OPENCNT&lt;/code&gt; field (remember that &lt;code&gt;UBYTE&lt;/code&gt; is 1 byte, &lt;code&gt;UWORD&lt;/code&gt; 2 bytes, and &lt;code&gt;APTR&lt;/code&gt; and &lt;code&gt;ULONG&lt;/code&gt; 4 bytes). This field is, as the comment reads, the "number of current opens".&lt;/p&gt;
&lt;p&gt;The last instruction of the &lt;code&gt;Open&lt;/code&gt; function is &lt;code&gt;rts&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;e&lt;code&gt;t&lt;/code&gt;urn from &lt;code&gt;s&lt;/code&gt;ubroutine) that returns to the instruction after the &lt;code&gt;jsr&lt;/code&gt; that called the function.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;Close&lt;/code&gt;, &lt;code&gt;Expunge&lt;/code&gt;, and the reserved slot&lt;/h2&gt;
&lt;p&gt;Immediately after the definition of the &lt;code&gt;Open&lt;/code&gt; function, we find the definition of &lt;code&gt;Close&lt;/code&gt;, listed in the vector table as &lt;code&gt;0x08a8&lt;/code&gt;, which becomes &lt;code&gt;0x1a7c + 0x08a8 = 0x2324&lt;/code&gt;. The next two entries in the vector table contain the same value &lt;code&gt;0x08ac&lt;/code&gt;, which translates to the absolute address &lt;code&gt;0x1a7c + 0x08ac = 0x2328&lt;/code&gt;. This address is then the location of both the &lt;code&gt;Expunge&lt;/code&gt; function and the reserved function that must return 0.&lt;/p&gt;
&lt;p&gt;The code of the &lt;code&gt;Close&lt;/code&gt; function is very simple, it just decrements the open counter (&lt;code&gt;0x20&lt;/code&gt; in the library). There is no explicit &lt;code&gt;rts&lt;/code&gt; as &lt;code&gt;Close&lt;/code&gt; uses the adjacent &lt;code&gt;Expunge&lt;/code&gt; code for that. Since it's impossible to remove the Exec library in the Amiga system, the &lt;code&gt;Expunge&lt;/code&gt; function of the Exec library just returns 0, which is exactly what the reserved function has to do (thus the same address in the vector table), and what &lt;code&gt;Close&lt;/code&gt; does after having decremented the open counter.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;; Close&lt;/span&gt;
&lt;span class="nl"&gt;00002324:&lt;/span&gt; &lt;span class="mi"&gt;536e&lt;/span&gt; &lt;span class="mi"&gt;0020&lt;/span&gt; &lt;span class="k"&gt;subq&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="nl"&gt;#0x1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0x20&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;; Expunge&lt;/span&gt;
&lt;span class="nl"&gt;00002328:&lt;/span&gt; &lt;span class="mi"&gt;7000&lt;/span&gt;      &lt;span class="k"&gt;moveq&lt;/span&gt;   &lt;span class="nl"&gt;#0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;0000232a:&lt;/span&gt; &lt;span class="mi"&gt;4e75&lt;/span&gt;      &lt;span class="k"&gt;rts&lt;/span&gt;     
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;&lt;code&gt;MakeFunctions&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;MakeFunctions&lt;/code&gt; routine is used by Exec to create the vector table at the beginning of the library when it is loaded in memory. You might recall that the vector table is created backward from the beginning of the library, thus allowing to use a simpler addressing scheme.&lt;/p&gt;
&lt;p&gt;The prototype of the &lt;code&gt;MakeFunctions&lt;/code&gt; routine is&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MakeFunctions&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addess&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vectors&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;d0&lt;/span&gt;                   &lt;span class="n"&gt;a0&lt;/span&gt;      &lt;span class="n"&gt;a1&lt;/span&gt;       &lt;span class="n"&gt;a2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and the code that we found in one of the previous investigations is at offset &lt;code&gt;0x15b2&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000015b2:&lt;/span&gt; &lt;span class="mi"&gt;2f0b&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,-(&lt;/span&gt;&lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000015b4:&lt;/span&gt; &lt;span class="mi"&gt;7000&lt;/span&gt;                      &lt;span class="k"&gt;moveq&lt;/span&gt;   &lt;span class="nl"&gt;#0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000015b6:&lt;/span&gt; &lt;span class="mi"&gt;220a&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;000015b8:&lt;/span&gt; &lt;span class="mi"&gt;6716&lt;/span&gt;                      &lt;span class="k"&gt;beq&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="mi"&gt;0x15d0&lt;/span&gt;
&lt;span class="nl"&gt;000015ba:&lt;/span&gt; &lt;span class="mi"&gt;3219&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)+,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;000015bc:&lt;/span&gt; &lt;span class="mi"&gt;0c41&lt;/span&gt; &lt;span class="mi"&gt;ffff&lt;/span&gt;                 &lt;span class="k"&gt;cmpi&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="p"&gt;#-&lt;/span&gt;&lt;span class="mi"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;000015c0:&lt;/span&gt; &lt;span class="mi"&gt;6722&lt;/span&gt;                      &lt;span class="k"&gt;beq&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="mi"&gt;0x15e4&lt;/span&gt;
&lt;span class="nl"&gt;000015c2:&lt;/span&gt; &lt;span class="mi"&gt;47f2&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1.w&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a3&lt;/span&gt;
&lt;span class="nl"&gt;000015c6:&lt;/span&gt; &lt;span class="mi"&gt;210b&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,-(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000015c8:&lt;/span&gt; &lt;span class="mi"&gt;313c&lt;/span&gt; &lt;span class="mi"&gt;4ef9&lt;/span&gt;                 &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="nl"&gt;#0x4ef9&lt;/span&gt;&lt;span class="p"&gt;,-(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000015cc:&lt;/span&gt; &lt;span class="mi"&gt;5c80&lt;/span&gt;                      &lt;span class="k"&gt;addq&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="nl"&gt;#0x6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000015ce:&lt;/span&gt; &lt;span class="mi"&gt;60ea&lt;/span&gt;                      &lt;span class="k"&gt;bra&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="mi"&gt;0x15ba&lt;/span&gt;
&lt;span class="nl"&gt;000015d0:&lt;/span&gt; &lt;span class="mi"&gt;2219&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)+,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;000015d2:&lt;/span&gt; &lt;span class="mi"&gt;0c81&lt;/span&gt; &lt;span class="mi"&gt;ffff&lt;/span&gt; &lt;span class="mi"&gt;ffff&lt;/span&gt;            &lt;span class="k"&gt;cmpi&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="p"&gt;#-&lt;/span&gt;&lt;span class="mi"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;000015d8:&lt;/span&gt; &lt;span class="mi"&gt;670a&lt;/span&gt;                      &lt;span class="k"&gt;beq&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="mi"&gt;0x15e4&lt;/span&gt;
&lt;span class="nl"&gt;000015da:&lt;/span&gt; &lt;span class="mi"&gt;2101&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;d1&lt;/span&gt;&lt;span class="p"&gt;,-(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000015dc:&lt;/span&gt; &lt;span class="mi"&gt;313c&lt;/span&gt; &lt;span class="mi"&gt;4ef9&lt;/span&gt;                 &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="nl"&gt;#0x4ef9&lt;/span&gt;&lt;span class="p"&gt;,-(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000015e0:&lt;/span&gt; &lt;span class="mi"&gt;5c80&lt;/span&gt;                      &lt;span class="k"&gt;addq&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="nl"&gt;#0x6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000015e2:&lt;/span&gt; &lt;span class="mi"&gt;60ec&lt;/span&gt;                      &lt;span class="k"&gt;bra&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="mi"&gt;0x15d0&lt;/span&gt;
&lt;span class="nl"&gt;000015e4:&lt;/span&gt; &lt;span class="mi"&gt;265f&lt;/span&gt;                      &lt;span class="k"&gt;movea&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;)+,&lt;/span&gt;&lt;span class="o"&gt;a3&lt;/span&gt;
&lt;span class="nl"&gt;000015e6:&lt;/span&gt; &lt;span class="mi"&gt;4e75&lt;/span&gt;                      &lt;span class="k"&gt;rts&lt;/span&gt;     
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The code is probably easier to read if we replace the addresses with some labels&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;Setup:&lt;/span&gt;
&lt;span class="nl"&gt;000015b2:&lt;/span&gt; &lt;span class="mi"&gt;2f0b&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,-(&lt;/span&gt;&lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000015b4:&lt;/span&gt; &lt;span class="mi"&gt;7000&lt;/span&gt;                      &lt;span class="k"&gt;moveq&lt;/span&gt;   &lt;span class="nl"&gt;#0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000015b6:&lt;/span&gt; &lt;span class="mi"&gt;220a&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;000015b8:&lt;/span&gt; &lt;span class="mi"&gt;6716&lt;/span&gt;                      &lt;span class="k"&gt;beq&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="n"&gt;Absolute&lt;/span&gt;

&lt;span class="nl"&gt;Relative:&lt;/span&gt;
&lt;span class="nl"&gt;000015ba:&lt;/span&gt; &lt;span class="mi"&gt;3219&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)+,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;000015bc:&lt;/span&gt; &lt;span class="mi"&gt;0c41&lt;/span&gt; &lt;span class="mi"&gt;ffff&lt;/span&gt;                 &lt;span class="k"&gt;cmpi&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="p"&gt;#-&lt;/span&gt;&lt;span class="mi"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;000015c0:&lt;/span&gt; &lt;span class="mi"&gt;6722&lt;/span&gt;                      &lt;span class="k"&gt;beq&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="n"&gt;Cleanup&lt;/span&gt;
&lt;span class="nl"&gt;000015c2:&lt;/span&gt; &lt;span class="mi"&gt;47f2&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1.w&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a3&lt;/span&gt;
&lt;span class="nl"&gt;000015c6:&lt;/span&gt; &lt;span class="mi"&gt;210b&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,-(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000015c8:&lt;/span&gt; &lt;span class="mi"&gt;313c&lt;/span&gt; &lt;span class="mi"&gt;4ef9&lt;/span&gt;                 &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="nl"&gt;#0x4ef9&lt;/span&gt;&lt;span class="p"&gt;,-(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000015cc:&lt;/span&gt; &lt;span class="mi"&gt;5c80&lt;/span&gt;                      &lt;span class="k"&gt;addq&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="nl"&gt;#0x6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000015ce:&lt;/span&gt; &lt;span class="mi"&gt;60ea&lt;/span&gt;                      &lt;span class="k"&gt;bra&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="n"&gt;Relative&lt;/span&gt;

&lt;span class="nl"&gt;Absolute:&lt;/span&gt;
&lt;span class="nl"&gt;000015d0:&lt;/span&gt; &lt;span class="mi"&gt;2219&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)+,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;000015d2:&lt;/span&gt; &lt;span class="mi"&gt;0c81&lt;/span&gt; &lt;span class="mi"&gt;ffff&lt;/span&gt; &lt;span class="mi"&gt;ffff&lt;/span&gt;            &lt;span class="k"&gt;cmpi&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="p"&gt;#-&lt;/span&gt;&lt;span class="mi"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;000015d8:&lt;/span&gt; &lt;span class="mi"&gt;670a&lt;/span&gt;                      &lt;span class="k"&gt;beq&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="n"&gt;Cleanup&lt;/span&gt;
&lt;span class="nl"&gt;000015da:&lt;/span&gt; &lt;span class="mi"&gt;2101&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;d1&lt;/span&gt;&lt;span class="p"&gt;,-(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000015dc:&lt;/span&gt; &lt;span class="mi"&gt;313c&lt;/span&gt; &lt;span class="mi"&gt;4ef9&lt;/span&gt;                 &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="nl"&gt;#0x4ef9&lt;/span&gt;&lt;span class="p"&gt;,-(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000015e0:&lt;/span&gt; &lt;span class="mi"&gt;5c80&lt;/span&gt;                      &lt;span class="k"&gt;addq&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="nl"&gt;#0x6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000015e2:&lt;/span&gt; &lt;span class="mi"&gt;60ec&lt;/span&gt;                      &lt;span class="k"&gt;bra&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="n"&gt;Absolute&lt;/span&gt;

&lt;span class="nl"&gt;Cleanup:&lt;/span&gt;
&lt;span class="nl"&gt;000015e4:&lt;/span&gt; &lt;span class="mi"&gt;265f&lt;/span&gt;                      &lt;span class="k"&gt;movea&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;)+,&lt;/span&gt;&lt;span class="o"&gt;a3&lt;/span&gt;
&lt;span class="nl"&gt;000015e6:&lt;/span&gt; &lt;span class="mi"&gt;4e75&lt;/span&gt;                      &lt;span class="k"&gt;rts&lt;/span&gt;     
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Setup&lt;/h2&gt;
&lt;p&gt;The first part of the code is&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;Setup:&lt;/span&gt;
&lt;span class="nl"&gt;000015b2:&lt;/span&gt; &lt;span class="mi"&gt;2f0b&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,-(&lt;/span&gt;&lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000015b4:&lt;/span&gt; &lt;span class="mi"&gt;7000&lt;/span&gt;                      &lt;span class="k"&gt;moveq&lt;/span&gt;   &lt;span class="nl"&gt;#0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000015b6:&lt;/span&gt; &lt;span class="mi"&gt;220a&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;000015b8:&lt;/span&gt; &lt;span class="mi"&gt;6716&lt;/span&gt;                      &lt;span class="k"&gt;beq&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="n"&gt;Absolute&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The first thing this code does is to save the &lt;code&gt;a3&lt;/code&gt; register in the stack because it will be changed during the routine.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;Setup:&lt;/span&gt;
&lt;span class="nl"&gt;000015b2:&lt;/span&gt; &lt;span class="mi"&gt;2f0b&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,-(&lt;/span&gt;&lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In Assembly, variables are provided by registers and thus are not namespaced, as the registers are the same through the whole program. This is why you should save and restore them and document which one you will change, for instance to return values.&lt;/p&gt;
&lt;p&gt;Secondly, the code sets the &lt;code&gt;d0&lt;/code&gt; register to 0.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000015b4:&lt;/span&gt; &lt;span class="mi"&gt;7000&lt;/span&gt;                      &lt;span class="k"&gt;moveq&lt;/span&gt;   &lt;span class="nl"&gt;#0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This register, according to the function prototype, will contain the final size of the jump table, and 0 is a sensible starting value.&lt;/p&gt;
&lt;p&gt;Lastly, the code moves the &lt;code&gt;a2&lt;/code&gt; register to &lt;code&gt;d1&lt;/code&gt; to be able to manipulate it. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000015b6:&lt;/span&gt; &lt;span class="mi"&gt;220a&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;000015b8:&lt;/span&gt; &lt;span class="mi"&gt;6716&lt;/span&gt;                      &lt;span class="k"&gt;beq&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="n"&gt;Absolute&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This, however, also sets the processor flags according to the value of &lt;code&gt;a2&lt;/code&gt; itself, and those flags are used in the next &lt;code&gt;beq.b&lt;/code&gt; instruction. If &lt;code&gt;a2&lt;/code&gt; contains the value 0 the table is absolute (code at &lt;code&gt;0x15d0&lt;/code&gt;, labelled &lt;code&gt;Absolute&lt;/code&gt; here) otherwise it is relative (code at &lt;code&gt;0x15ba&lt;/code&gt;, labelled &lt;code&gt;Relative&lt;/code&gt; here).&lt;/p&gt;
&lt;h2&gt;Relative&lt;/h2&gt;
&lt;p&gt;The second section manages relative jump vectors&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;Relative:&lt;/span&gt;
&lt;span class="nl"&gt;000015ba:&lt;/span&gt; &lt;span class="mi"&gt;3219&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)+,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;000015bc:&lt;/span&gt; &lt;span class="mi"&gt;0c41&lt;/span&gt; &lt;span class="mi"&gt;ffff&lt;/span&gt;                 &lt;span class="k"&gt;cmpi&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="p"&gt;#-&lt;/span&gt;&lt;span class="mi"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;000015c0:&lt;/span&gt; &lt;span class="mi"&gt;6722&lt;/span&gt;                      &lt;span class="k"&gt;beq&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="n"&gt;Cleanup&lt;/span&gt;
&lt;span class="nl"&gt;000015c2:&lt;/span&gt; &lt;span class="mi"&gt;47f2&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1.w&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a3&lt;/span&gt;
&lt;span class="nl"&gt;000015c6:&lt;/span&gt; &lt;span class="mi"&gt;210b&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,-(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000015c8:&lt;/span&gt; &lt;span class="mi"&gt;313c&lt;/span&gt; &lt;span class="mi"&gt;4ef9&lt;/span&gt;                 &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="nl"&gt;#0x4ef9&lt;/span&gt;&lt;span class="p"&gt;,-(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000015cc:&lt;/span&gt; &lt;span class="mi"&gt;5c80&lt;/span&gt;                      &lt;span class="k"&gt;addq&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="nl"&gt;#0x6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000015ce:&lt;/span&gt; &lt;span class="mi"&gt;60ea&lt;/span&gt;                      &lt;span class="k"&gt;bra&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="n"&gt;Relative&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This fetches one of the vectors from the address stored in &lt;code&gt;a1&lt;/code&gt; (the address of the vector table), immediately incrementing the register value to point at the next vector.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;Relative:&lt;/span&gt;
&lt;span class="nl"&gt;000015ba:&lt;/span&gt; &lt;span class="mi"&gt;3219&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)+,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;then compares it with &lt;code&gt;0xffff&lt;/code&gt; (or &lt;code&gt;#-0x1&lt;/code&gt;) to see if we reached the end of the table. In that case the code jumps to the fourth section (&lt;code&gt;0x15e4&lt;/code&gt;, labelled &lt;code&gt;Cleanup&lt;/code&gt;), otherwise the execution continues with the next instruction&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000015bc:&lt;/span&gt; &lt;span class="mi"&gt;0c41&lt;/span&gt; &lt;span class="mi"&gt;ffff&lt;/span&gt;                 &lt;span class="k"&gt;cmpi&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="p"&gt;#-&lt;/span&gt;&lt;span class="mi"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;000015c0:&lt;/span&gt; &lt;span class="mi"&gt;6722&lt;/span&gt;                      &lt;span class="k"&gt;beq&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="n"&gt;Cleanup&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The routine then loads the effective address of the relative vector using &lt;code&gt;a2&lt;/code&gt; as the base addressing, and stores it in &lt;code&gt;a3&lt;/code&gt;. This register now contains the final entry that will be part of the jump table.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000015c2:&lt;/span&gt; &lt;span class="mi"&gt;47f2&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1.w&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Since the address of the jump table is contained in &lt;code&gt;a0&lt;/code&gt;, the resulting absolute vector is stored there, then the code stores the value &lt;code&gt;0x4ef9&lt;/code&gt; which is the code for the &lt;code&gt;jmp&lt;/code&gt; instruction (more on this later)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000015c6:&lt;/span&gt; &lt;span class="mi"&gt;210b&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,-(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000015c8:&lt;/span&gt; &lt;span class="mi"&gt;313c&lt;/span&gt; &lt;span class="mi"&gt;4ef9&lt;/span&gt;                 &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="nl"&gt;#0x4ef9&lt;/span&gt;&lt;span class="p"&gt;,-(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note that since we are storing the jump table at negative addresses starting from the library's base pointer we have to copy the argument (the address) first and then the function (the code for &lt;code&gt;jmp&lt;/code&gt;). The last thing this part of the code does is to add 6 to the size of the jump table (1 word for the instruction, 2 words for the address) and then jumps back to the beginning of the loop.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000015cc:&lt;/span&gt; &lt;span class="mi"&gt;5c80&lt;/span&gt;                      &lt;span class="k"&gt;addq&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="nl"&gt;#0x6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000015ce:&lt;/span&gt; &lt;span class="mi"&gt;60ea&lt;/span&gt;                      &lt;span class="k"&gt;bra&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="n"&gt;Relative&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Absolute&lt;/h2&gt;
&lt;p&gt;The third section is very similar to the second one, because it performs the same actions, only with absolute addresses instead of relative ones.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000015d0:&lt;/span&gt; &lt;span class="mi"&gt;2219&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)+,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;000015d2:&lt;/span&gt; &lt;span class="mi"&gt;0c81&lt;/span&gt; &lt;span class="mi"&gt;ffff&lt;/span&gt; &lt;span class="mi"&gt;ffff&lt;/span&gt;            &lt;span class="k"&gt;cmpi&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="p"&gt;#-&lt;/span&gt;&lt;span class="mi"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;000015d8:&lt;/span&gt; &lt;span class="mi"&gt;670a&lt;/span&gt;                      &lt;span class="k"&gt;beq&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="n"&gt;Cleanup&lt;/span&gt;
&lt;span class="nl"&gt;000015da:&lt;/span&gt; &lt;span class="mi"&gt;2101&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="o"&gt;d1&lt;/span&gt;&lt;span class="p"&gt;,-(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000015dc:&lt;/span&gt; &lt;span class="mi"&gt;313c&lt;/span&gt; &lt;span class="mi"&gt;4ef9&lt;/span&gt;                 &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="nl"&gt;#0x4ef9&lt;/span&gt;&lt;span class="p"&gt;,-(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;000015e0:&lt;/span&gt; &lt;span class="mi"&gt;5c80&lt;/span&gt;                      &lt;span class="k"&gt;addq&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="nl"&gt;#0x6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;000015e2:&lt;/span&gt; &lt;span class="mi"&gt;60ec&lt;/span&gt;                      &lt;span class="k"&gt;bra&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="n"&gt;Absolute&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The only difference with the previous section is that there is no need to load the effective address, as the vale contained in &lt;code&gt;d1&lt;/code&gt; is already absolute, so this latter can be stored directly.&lt;/p&gt;
&lt;h2&gt;Cleanup&lt;/h2&gt;
&lt;p&gt;The last section simply restores the stack pointer, popping the value of the &lt;code&gt;a3&lt;/code&gt; register where the pointer was previously saved, and returns to the caller.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000015e4:&lt;/span&gt; &lt;span class="mi"&gt;265f&lt;/span&gt;                      &lt;span class="k"&gt;movea&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;)+,&lt;/span&gt;&lt;span class="o"&gt;a3&lt;/span&gt;
&lt;span class="nl"&gt;000015e6:&lt;/span&gt; &lt;span class="mi"&gt;4e75&lt;/span&gt;                      &lt;span class="k"&gt;rts&lt;/span&gt;     
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Self modifying code&lt;/h1&gt;
&lt;p&gt;The creation of the jump table performed by the &lt;code&gt;MakeFunctions&lt;/code&gt; routine leverages a very powerful feature of any assembly language, that is being able to produce code that self modifies. This feature comes from a property of machine languages called &lt;a href="https://en.wikipedia.org/wiki/Homoiconicity"&gt;homoiconicity&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The basic idea of homoiconicity is that the language doesn't consider data and code two different things, thus allowing to use the code as an input for routines and to change it programmatically. Pay attention that self-modifying code is just one of the implications of homoiconicity, and not its definition.&lt;/p&gt;
&lt;p&gt;Homoiconicity is a feature rarely provided by languages. It is very powerful, but it basically forces to keep the language at the level of its own AST (Abstract Syntax Tree), which in turn means that you cannot add a proper abstraction, or, if you prefer, a proper high level language, if we identify with this term a computer language that is similar to the human language.&lt;/p&gt;
&lt;p&gt;Famous examples of high level languages that are homoiconic are Lisp and Prolog. Lisp is a language that manages lists and its syntax is based on... lists. This means that you can pass Lisp code to a function and transform it like you would do with standard data.&lt;/p&gt;
&lt;p&gt;Back to the Motorola Assembly code, the line we are interested in is &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000015c8:&lt;/span&gt; &lt;span class="mi"&gt;313c&lt;/span&gt; &lt;span class="mi"&gt;4ef9&lt;/span&gt;                 &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="nl"&gt;#0x4ef9&lt;/span&gt;&lt;span class="p"&gt;,-(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This decrements the address contained in &lt;code&gt;a0&lt;/code&gt; by 2 bytes, then stores at the resulting address the hexadecimal number &lt;code&gt;0x4ef9&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The interesting part is that the number &lt;code&gt;0x4ef9&lt;/code&gt; has a specific meaning for the Motorola 68000 processor, and namely that of the &lt;code&gt;jmp&lt;/code&gt; instruction. This is clearly shown by the tables in the Programmer's Reference Manual (Section 8, Instruction Format Summary, 8-15).&lt;/p&gt;
&lt;p&gt;First we have to convert the number in binary, and we get&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0x4ef9 -&amp;gt; 0100 1110 1111 1001
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The first 10 bits (&lt;code&gt;0100 1110 11&lt;/code&gt;) already identify a &lt;code&gt;jmp&lt;/code&gt; instruction. The following 6 bits (&lt;code&gt;111 001&lt;/code&gt;) identify the addressing mode, which in this case is &lt;code&gt;Absolute Long&lt;/code&gt; or &lt;code&gt;(xxx).L&lt;/code&gt; (Programmer's Reference Manual, 4-108). This instruction shall then be followed by a 4 bytes absolute address.&lt;/p&gt;
&lt;p&gt;With that &lt;code&gt;move.w&lt;/code&gt;, then, the code writes in memory some Assembly code. Techniques like this have been and are used by games and viruses to obfuscate the code, as a static analysis of the binary will not reveal what will be there only at runtime!&lt;/p&gt;
&lt;h1&gt;Resources&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Motorola M68000 Family Programmer's Reference Manual &lt;a href="https://www.nxp.com/docs/en/reference-manual/M68000PRM.pdf"&gt;PDF here&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://amigadev.elowar.com"&gt;AmigaOS Developer Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Feedback&lt;/h1&gt;
&lt;p&gt;Feel free to reach me on &lt;a href="https://twitter.com/thedigicat"&gt;Twitter&lt;/a&gt; if you have questions. The &lt;a href="http://github.com/TheDigitalCatOnline/thedigitalcatonline.github.com/issues"&gt;GitHub issues&lt;/a&gt; page is the best place to submit corrections.&lt;/p&gt;</content><category term="assembly"></category><category term="amiga"></category><category term="retroprogramming"></category></entry><entry><title>Exploring the Amiga - Part 3</title><link href="http://blog.thedigitalcatonline.com/blog/2018/06/08/exploring-the-amiga-3/" rel="alternate"></link><published>2018-06-08T12:30:00+01:00</published><updated>2018-06-24T22:30:00+00:00</updated><author><name>Leonardo Giordani</name></author><id>tag:blog.thedigitalcatonline.com,2018-06-08:/blog/2018/06/08/exploring-the-amiga-3/</id><summary type="html"></summary><content type="html">&lt;h1&gt;Exec and the vector table&lt;/h1&gt;
&lt;p&gt;The Exec library is the base library of the Amiga system. This library is loaded in memory at boot time, and it is always open and available. Once loaded, it has the same structure of any other library, that is a prefix containing the jump table in reverse order, then the actual code.&lt;/p&gt;
&lt;p&gt;The trick here is that Exec is the library used to load in memory other libraries, so the function that creates the structure in memory of a given library is contained here. To install Exec in memory, thus, we need to use a function which is part of the library itself.&lt;/p&gt;
&lt;p&gt;This is one of the powers of the Assembly language. The property of treating the code as if it was pure data is called homoiconicity, and is something that can be rarely found in other languages. Lisp is a good example of a higher level homoiconic language.&lt;/p&gt;
&lt;p&gt;Back to our vector table, we have to find a way to use the Exec library to install in memory the Exec library itself. The concept is not that complex, actually. The pseudocode is something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;vectors&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;function1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;vectors&lt;/span&gt;
    &lt;span class="n"&gt;function2&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;vectors&lt;/span&gt;
    &lt;span class="n"&gt;function3&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;vectors&lt;/span&gt;
&lt;span class="n"&gt;function1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;code&lt;/span&gt;
    &lt;span class="o"&gt;[...]&lt;/span&gt;
&lt;span class="n"&gt;function2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;code&lt;/span&gt;
    &lt;span class="o"&gt;[...]&lt;/span&gt;
&lt;span class="n"&gt;function3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;code&lt;/span&gt;
    &lt;span class="o"&gt;[...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In this situation we have 3 functions defined at the addresses &lt;code&gt;function1&lt;/code&gt;, &lt;code&gt;function2&lt;/code&gt;, and &lt;code&gt;function3&lt;/code&gt;. Somewhere in the code at the address &lt;code&gt;vectors&lt;/code&gt; there is a plain list that containes the addresses of those functions. Since the code can be relocated this list contains offsets relative to the &lt;code&gt;vectors&lt;/code&gt; table itself. So the first element of the table will be &lt;code&gt;function1-vectors&lt;/code&gt;, that is the subtraction between the two addresses, and so on.&lt;/p&gt;
&lt;p&gt;For example we might have&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0042 0122
0044 01b8
0046 02d1
[...]
0164 code of function1
[...]
01fa code of function2
[...]
0313 code of function3
[...]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Where the entry of the table are &lt;code&gt;0x164-0x42 = 0x122&lt;/code&gt;, &lt;code&gt;0x1fa-0x42 = 0x1b8&lt;/code&gt;, and &lt;code&gt;0x313-0x42 = 0x2d1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The vectors table, thus, is the source from which we can calculate the jump table. The code to perform this, however, is contained in one of the functions itself, let's say the number 2&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;function1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;code&lt;/span&gt;
    &lt;span class="o"&gt;[...]&lt;/span&gt;
&lt;span class="n"&gt;function2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="k"&gt;each&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;create&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;jump&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt; &lt;span class="n"&gt;entry&lt;/span&gt; &lt;span class="n"&gt;relative&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;function3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;code&lt;/span&gt;
    &lt;span class="o"&gt;[...]&lt;/span&gt;
&lt;span class="n"&gt;vectors&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;function1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;vectors&lt;/span&gt;
    &lt;span class="n"&gt;function2&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;vectors&lt;/span&gt;
    &lt;span class="n"&gt;function3&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;vectors&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see the function at &lt;code&gt;function2&lt;/code&gt; (in this example) depends on a &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; and a &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; parameters which will be contained in some register. At this point, since the address &lt;code&gt;function2&lt;/code&gt; is known, there can be some code that runs the function on the table contained in the code itself&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;setup&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;function2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;vectors_offset&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;setup&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;function1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;code&lt;/span&gt;
    &lt;span class="o"&gt;[...]&lt;/span&gt;
&lt;span class="n"&gt;function2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="k"&gt;each&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;vector&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt; &lt;span class="n"&gt;create&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;jump&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt; &lt;span class="n"&gt;entry&lt;/span&gt; &lt;span class="n"&gt;relative&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;START&lt;/span&gt;
&lt;span class="n"&gt;function3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;code&lt;/span&gt;
    &lt;span class="o"&gt;[...]&lt;/span&gt;
&lt;span class="n"&gt;vectors&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;function1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;vectors&lt;/span&gt;
    &lt;span class="n"&gt;function2&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;vectors&lt;/span&gt;
    &lt;span class="n"&gt;function3&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;vectors&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;where &lt;code&gt;&amp;lt;vectors_offset&amp;gt;&lt;/code&gt; is a hardcoded offset (as the displacement of &lt;code&gt;vectors&lt;/code&gt; relative to &lt;code&gt;setup&lt;/code&gt; is known) and &lt;code&gt;setup&lt;/code&gt; is the effective address that the &lt;code&gt;setup&lt;/code&gt; routine has at runtime.&lt;/p&gt;
&lt;p&gt;This mechanism creates then a library that can install other libraries through a given function, but that can at the same time install itself.&lt;/p&gt;
&lt;h1&gt;The Kickstart vector table&lt;/h1&gt;
&lt;p&gt;An actual example of the vector table mechanism can be found in the Kickstart code. Kickstart is the BIOS of the Amiga system, and is loaded at boot time either from disk (Amiga 1000 and some Amiga 3000) or from a ROM.&lt;/p&gt;
&lt;p&gt;The code of Kickstart 1.3 can be found &lt;a href="https://www.romcollector.com/emulators-firmware-i-29.html"&gt;here&lt;/a&gt; and you can easily disassemble it with vdasm&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vda68k Kickstart1.3.rom &amp;gt; Kickstart1.3.asm
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Inside this code we can see a practical implementation of the mechanism described above.&lt;/p&gt;
&lt;p&gt;The mandatory disclaimer: &lt;strong&gt;to use the Amiga Kickstart ROM images you must own a license.&lt;/strong&gt; (see the Resources section). This website is against piracy of dead and discontinued systems ;)&lt;/p&gt;
&lt;p&gt;When you disassemble some binary code, however, you don't get some nice source code written in a high level language. Well, not with a simple disassembler like vdasm, anyway. What you get is the one to one interpretation of the binary values according to the processor's conventions, and this includes parts of the binary file that are pure data. The disassembler has no way to know if some binary number represents an instruction or a pure number. Moreover, there is no trace of the original labels used by the author(s) of the code, as they are lost in the translation to machine language, when they are converted to pure addresses.&lt;/p&gt;
&lt;p&gt;The practice of understanding how a system works starting from the pure implementation is called "reversing", and personally I consider it one of the most fascinating tasks a programmer can face.&lt;/p&gt;
&lt;p&gt;The purpose of the present investigation is to find the Kickstart 1.3 vector table, and with that to find the position and implementation of the Exec functions. Well, let's start.&lt;/p&gt;
&lt;h2&gt;Step 1&lt;/h2&gt;
&lt;p&gt;I know that &lt;code&gt;MakeFunctions&lt;/code&gt; is used to create in memory the structure of Exec itself. So I know that somewhere that function is invoked on the code that I am studying.&lt;/p&gt;
&lt;p&gt;Since one of the parameters of the &lt;code&gt;MakeFunctions&lt;/code&gt; routine is the name of the library a good starting point might be a string containing &lt;code&gt;exec.library&lt;/code&gt; (which is the standard name of this library in the Amiga system). Once I find that string I can look for a function call that uses its address as a parameter.&lt;/p&gt;
&lt;p&gt;The byte sequence that represents that string (using ASCII) is &lt;code&gt;65 78 65 63 2E 6C 69 62 72 61 72 79&lt;/code&gt;. In Kickstart 1.3 the offset of this string is &lt;code&gt;0x00a8&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Remember that what you see in the disassembled code is not a string. The disassembler tries to convert everything into instructions, so you will find something like&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;000000a8:&lt;/span&gt; &lt;span class="mi"&gt;6578&lt;/span&gt;                      &lt;span class="k"&gt;bcs&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="mi"&gt;0x122&lt;/span&gt;
&lt;span class="nl"&gt;000000aa:&lt;/span&gt; &lt;span class="mi"&gt;6563&lt;/span&gt;                      &lt;span class="k"&gt;bcs&lt;/span&gt;&lt;span class="o"&gt;.b&lt;/span&gt;   &lt;span class="mi"&gt;0x10f&lt;/span&gt;
&lt;span class="nl"&gt;000000ac:&lt;/span&gt; &lt;span class="mi"&gt;2e6c&lt;/span&gt; &lt;span class="mi"&gt;6962&lt;/span&gt;                 &lt;span class="k"&gt;movea&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt; &lt;span class="mi"&gt;0x6962&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;sp&lt;/span&gt;
&lt;span class="nl"&gt;000000b0:&lt;/span&gt; &lt;span class="mi"&gt;7261&lt;/span&gt;                      &lt;span class="k"&gt;moveq&lt;/span&gt;   &lt;span class="nl"&gt;#0x61&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;span class="nl"&gt;000000b2:&lt;/span&gt; &lt;span class="mi"&gt;7279&lt;/span&gt;                      &lt;span class="k"&gt;moveq&lt;/span&gt;   &lt;span class="nl"&gt;#0x79&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When looking for strings it's better to use a hexadecimal editor that can show and search in the ASCII representation of the binary code.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Search exec.library string" src="/images/exploring-the-amiga-3/search-exec-library-string.png"&gt;&lt;/p&gt;
&lt;p&gt;We know that Kickstart is loaded at address 0xfc0000 (Amiga System Programmer's Guide, page 67), so all the 16-bit addresses are relative to 0x00fc. The library name pointer is then &lt;code&gt;00fc 00a8&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Step 2&lt;/h2&gt;
&lt;p&gt;In the Amiga system all libraries have a specific structure when loaded in memory. Apart from the prefixed jump table, the library code itself has a fixed structure that allows us to read and use it.&lt;/p&gt;
&lt;p&gt;First of all all libraries in memory are nodes of a linked list, so we expect to find the structure of the node itself. Then, inside the node, we expect to find the actual library structure.&lt;/p&gt;
&lt;p&gt;The include file &lt;code&gt;include_i/exec/nodes.i&lt;/code&gt; tells us that a standard linked list node has the following structure&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class="n"&gt;STRUCTURE&lt;/span&gt;    &lt;span class="n"&gt;LN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="c1"&gt;; List Node&lt;/span&gt;
    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;LN_SUCC&lt;/span&gt; &lt;span class="c1"&gt;; Pointer to next (successor)&lt;/span&gt;
    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;LN_PRED&lt;/span&gt; &lt;span class="c1"&gt;; Pointer to previous (predecessor)&lt;/span&gt;
    &lt;span class="n"&gt;UBYTE&lt;/span&gt;   &lt;span class="n"&gt;LN_TYPE&lt;/span&gt;
    &lt;span class="n"&gt;BYTE&lt;/span&gt;    &lt;span class="n"&gt;LN_PRI&lt;/span&gt;  &lt;span class="c1"&gt;; Priority, for sorting&lt;/span&gt;
    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;LN_NAME&lt;/span&gt; &lt;span class="c1"&gt;; ID string, null terminated&lt;/span&gt;
    &lt;span class="n"&gt;LABEL&lt;/span&gt;   &lt;span class="n"&gt;LN_SIZE&lt;/span&gt; &lt;span class="c1"&gt;; Note: word aligned&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The two 32-bit pointers &lt;code&gt;LN_SUCC&lt;/code&gt; and &lt;code&gt;LN_PRED&lt;/code&gt; are created when the node is loaded in memory, so we need to look for the rest of the structure, namely 1 byte with &lt;code&gt;LN_TYPE&lt;/code&gt;, 1 byte with &lt;code&gt;LN_PRI&lt;/code&gt; and 4 bytes with &lt;code&gt;LN_NAME&lt;/code&gt;. From the same file &lt;code&gt;include_i/exec/nodes.i&lt;/code&gt; we know that the note type for a library is &lt;code&gt;09&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;NT_LIBRARY&lt;/span&gt;  &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So the pattern we are looking for is &lt;code&gt;09XX 00fc 00a8&lt;/code&gt;, respectively the node type (&lt;code&gt;09&lt;/code&gt;), an unknown priority (&lt;code&gt;XX&lt;/code&gt;), and the library name pointer &lt;code&gt;00fc 00a8&lt;/code&gt;. We also know that the pattern is likely to be stored towards the beginning of the whole ROM, as one of the first things the library will do is to create its own structure in memory. This last assumption is not to be taken for granted, but it's a reasonable one.&lt;/p&gt;
&lt;p&gt;In the Kickstart 1.3 code this pattern can be found at offset &lt;code&gt;0x030c&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Search library pattern" src="/images/exploring-the-amiga-3/search-library-pattern.png"&gt;&lt;/p&gt;
&lt;p&gt;If this is the correct position of the node structure, we expect to find just after it the structure of the library as described in the include file &lt;code&gt;include_i/exec/libraries.i&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="n"&gt;STRUCTURE&lt;/span&gt; &lt;span class="n"&gt;LIB&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LN_SIZE&lt;/span&gt;     
    &lt;span class="n"&gt;UBYTE&lt;/span&gt;   &lt;span class="n"&gt;LIB_FLAGS&lt;/span&gt;           &lt;span class="c1"&gt;; see below&lt;/span&gt;
    &lt;span class="n"&gt;UBYTE&lt;/span&gt;   &lt;span class="n"&gt;LIB_pad&lt;/span&gt;         &lt;span class="c1"&gt;; must be zero&lt;/span&gt;
    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;LIB_NEGSIZE&lt;/span&gt;     &lt;span class="c1"&gt;; number of bytes before LIB&lt;/span&gt;
    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;LIB_POSSIZE&lt;/span&gt;     &lt;span class="c1"&gt;; number of bytes after LIB&lt;/span&gt;
    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;LIB_VERSION&lt;/span&gt;     &lt;span class="c1"&gt;; major&lt;/span&gt;
    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;LIB_REVISION&lt;/span&gt;        &lt;span class="c1"&gt;; minor&lt;/span&gt;
    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;LIB_IDSTRING&lt;/span&gt;        &lt;span class="c1"&gt;; ASCII identification&lt;/span&gt;
    &lt;span class="n"&gt;ULONG&lt;/span&gt;   &lt;span class="n"&gt;LIB_SUM&lt;/span&gt;         &lt;span class="c1"&gt;; the system-calculated checksum&lt;/span&gt;
    &lt;span class="n"&gt;UWORD&lt;/span&gt;   &lt;span class="n"&gt;LIB_OPENCNT&lt;/span&gt;     &lt;span class="c1"&gt;; number of current opens&lt;/span&gt;
    &lt;span class="n"&gt;LABEL&lt;/span&gt;   &lt;span class="n"&gt;LIB_SIZE&lt;/span&gt;    &lt;span class="c1"&gt;;Warning: Size is not a longword multiple!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The binary code of Kickstart 1.3 from address &lt;code&gt;0xfc030c&lt;/code&gt; is indeed the following&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;0000030c:&lt;/span&gt; &lt;span class="mi"&gt;09&lt;/span&gt;          &lt;span class="c1"&gt;; LN_TYPE&lt;/span&gt;
&lt;span class="nl"&gt;0000030d:&lt;/span&gt; &lt;span class="mi"&gt;00&lt;/span&gt;          &lt;span class="c1"&gt;; LN_PRI&lt;/span&gt;
&lt;span class="nl"&gt;0000030e:&lt;/span&gt; &lt;span class="mi"&gt;00fc&lt;/span&gt; &lt;span class="mi"&gt;00a8&lt;/span&gt;   &lt;span class="c1"&gt;; LN_NAME&lt;/span&gt;
&lt;span class="nl"&gt;00000312:&lt;/span&gt; &lt;span class="mi"&gt;06&lt;/span&gt;          &lt;span class="c1"&gt;; LIB_FLAGS&lt;/span&gt;
&lt;span class="nl"&gt;00000313:&lt;/span&gt; &lt;span class="mi"&gt;00&lt;/span&gt;          &lt;span class="c1"&gt;; LIB_pad&lt;/span&gt;
&lt;span class="nl"&gt;00000314:&lt;/span&gt; &lt;span class="mi"&gt;0000&lt;/span&gt;        &lt;span class="c1"&gt;; LIB_NEGSIZE&lt;/span&gt;
&lt;span class="nl"&gt;00000316:&lt;/span&gt; &lt;span class="mi"&gt;024c&lt;/span&gt;        &lt;span class="c1"&gt;; LIB_POSSIZE&lt;/span&gt;
&lt;span class="nl"&gt;00000318:&lt;/span&gt; &lt;span class="mi"&gt;0022&lt;/span&gt;        &lt;span class="c1"&gt;; LIB_VERSION&lt;/span&gt;
&lt;span class="nl"&gt;0000031a:&lt;/span&gt; &lt;span class="mi"&gt;0002&lt;/span&gt;        &lt;span class="c1"&gt;; LIB_REVISION&lt;/span&gt;
&lt;span class="nl"&gt;0000031c:&lt;/span&gt; &lt;span class="mi"&gt;00fc&lt;/span&gt; &lt;span class="mi"&gt;0018&lt;/span&gt;   &lt;span class="c1"&gt;; LIB_IDSTRING&lt;/span&gt;
&lt;span class="nl"&gt;00000320:&lt;/span&gt; &lt;span class="mi"&gt;0000&lt;/span&gt; &lt;span class="mi"&gt;0000&lt;/span&gt;   &lt;span class="c1"&gt;; LIB_SUM&lt;/span&gt;
&lt;span class="nl"&gt;00000324:&lt;/span&gt; &lt;span class="mi"&gt;0001&lt;/span&gt;        &lt;span class="c1"&gt;; LIB_OPENCNT&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;From this I know that the version of &lt;code&gt;exec&lt;/code&gt; contained in this Kickstart is 34 (&lt;code&gt;0x22&lt;/code&gt;) revision 2 (&lt;code&gt;0x02&lt;/code&gt;), and this is confirmed byt the ID string at address &lt;code&gt;0xfc0018&lt;/code&gt;, which is &lt;code&gt;exec 34.2 (28 Oct 1987)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Exec version string" src="/images/exploring-the-amiga-3/exec-version-string.png"&gt;&lt;/p&gt;
&lt;h2&gt;Step 3&lt;/h2&gt;
&lt;p&gt;What we are really interested in, at this point, is where the address of this structure is mentioned in the code, as it will be used to create the library structure. Since after creating the library structure the &lt;code&gt;MakeFunctions&lt;/code&gt; routine will be invoked we can know from here where this latter is defined.&lt;/p&gt;
&lt;p&gt;The structure is at address &lt;code&gt;0x030c&lt;/code&gt; and we are looking for and instruction like &lt;code&gt;lea 0x30c(pc),ax&lt;/code&gt;, where &lt;code&gt;ax&lt;/code&gt; is one of the address registers &lt;code&gt;a0&lt;/code&gt;-&lt;code&gt;a7&lt;/code&gt;. Loading the address of a table in a register is the standard way to loop on the table to modify it or to copy the bytes somewhere. &lt;/p&gt;
&lt;p&gt;(The 68000 does not allow you to execute a MOVE instruction with a destination relative to the program counter (PC). In the view of the 68000 designers, code should not patch itself. If you must change a table in the middle of code, you must point to it with an instruction like LEA TABLE(PC),An and then alter it through An. (Self-modifying code is especially bad for 68000 programs that may someday run on the 68020, because the 68020's instruction cache normally assumes that code is pure.) from http://www.easy68k.com/paulrsm/doc/trick68k.htm)&lt;/p&gt;
&lt;p&gt;At address &lt;code&gt;0x0364&lt;/code&gt; we find the following code&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;0360:&lt;/span&gt; &lt;span class="mi"&gt;43ee&lt;/span&gt; &lt;span class="mi"&gt;0008&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;
&lt;span class="nl"&gt;0364:&lt;/span&gt; &lt;span class="mi"&gt;41fa&lt;/span&gt; &lt;span class="mi"&gt;ffa6&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x30c&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;
&lt;span class="nl"&gt;0368:&lt;/span&gt; &lt;span class="mi"&gt;700c&lt;/span&gt;                      &lt;span class="k"&gt;moveq&lt;/span&gt;   &lt;span class="nl"&gt;#0xc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;d0&lt;/span&gt;
&lt;span class="nl"&gt;036a:&lt;/span&gt; &lt;span class="mi"&gt;32d8&lt;/span&gt;                      &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)+,(&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)+&lt;/span&gt;
&lt;span class="nl"&gt;036c:&lt;/span&gt; &lt;span class="mi"&gt;51c8&lt;/span&gt; &lt;span class="mi"&gt;fffc&lt;/span&gt;                 &lt;span class="k"&gt;dbf&lt;/span&gt;     &lt;span class="o"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0x36a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;which actually installs in memory the exec library. Let's analyse this code instruction by instruction.&lt;/p&gt;
&lt;p&gt;Since the ExecBase address is contained in &lt;code&gt;a6&lt;/code&gt; (this is done previously in the code), that address is incremented by 8 and the result is copied into the &lt;code&gt;a1&lt;/code&gt; register. The 8 bytes leave space for the &lt;code&gt;LN_SUCC&lt;/code&gt; and &lt;code&gt;LN_PRED&lt;/code&gt; pointers. Then, the code loads the address of the table in &lt;code&gt;a0&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;The loop is performed on 26 bytes. The number 12 (&lt;code&gt;0xc&lt;/code&gt;) is copied  into &lt;code&gt;d0&lt;/code&gt;, but the instruction &lt;code&gt;dbf&lt;/code&gt; (&lt;code&gt;dbra&lt;/code&gt; in some assemblers) keeps jumping to &lt;code&gt;0x36a&lt;/code&gt; until the value of &lt;code&gt;d0&lt;/code&gt; is -1, so it is actually performing the loop code 13 times. Since the &lt;code&gt;move.w&lt;/code&gt; instruction moves words we are copying 26 bytes, which is exactly the size of the library node from &lt;code&gt;LN_TYPE&lt;/code&gt; to &lt;code&gt;LIB_OPENCNT&lt;/code&gt; included.&lt;/p&gt;
&lt;p&gt;The next 5 instructions are&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;0370:&lt;/span&gt; &lt;span class="mi"&gt;204e&lt;/span&gt;                      &lt;span class="k"&gt;movea&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt; &lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;
&lt;span class="nl"&gt;0372:&lt;/span&gt; &lt;span class="mi"&gt;43fa&lt;/span&gt; &lt;span class="mi"&gt;1708&lt;/span&gt;                 &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x1a7c&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;
&lt;span class="nl"&gt;0376:&lt;/span&gt; &lt;span class="mi"&gt;2449&lt;/span&gt;                      &lt;span class="k"&gt;movea&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt; &lt;span class="o"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a2&lt;/span&gt;
&lt;span class="nl"&gt;0378:&lt;/span&gt; &lt;span class="mi"&gt;6100&lt;/span&gt; &lt;span class="mi"&gt;1238&lt;/span&gt;                 &lt;span class="k"&gt;bsr&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;   &lt;span class="mi"&gt;0x15b2&lt;/span&gt;
&lt;span class="nl"&gt;037c:&lt;/span&gt; &lt;span class="mi"&gt;3d40&lt;/span&gt; &lt;span class="mi"&gt;0010&lt;/span&gt;                 &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;  &lt;span class="o"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0x10&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;From the &lt;a href="http://amigadev.elowar.com/read/ADCD_2.1/Includes_and_Autodocs_3._guide/node021A.html"&gt;documentation&lt;/a&gt; we know that &lt;code&gt;MakeFunctions&lt;/code&gt; has the following prototype&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MakeFunctions&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vectors&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;d0&lt;/span&gt;                   &lt;span class="n"&gt;a0&lt;/span&gt;       &lt;span class="n"&gt;a1&lt;/span&gt;       &lt;span class="n"&gt;a2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;where &lt;code&gt;address&lt;/code&gt; is the address where the jump table will be constructed, &lt;code&gt;vectors&lt;/code&gt; is a table that lists the function addresses (the onewe are looking for) and &lt;code&gt;offset&lt;/code&gt; tells the function if the function addresses are absolute (if value is &lt;code&gt;0&lt;/code&gt;) or relative (in which case offset is the base for the displacement). The list of addresses has to be -1-terminated (&lt;code&gt;0xffff&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;So the first line stores in &lt;code&gt;a0&lt;/code&gt; the content of &lt;code&gt;a6&lt;/code&gt;, which is the ExecBase address. This is where we want to install the library. The second line loads the address of the vectors table in &lt;code&gt;a1&lt;/code&gt; and the same value is stored in &lt;code&gt;a2&lt;/code&gt;. Then the code branches to the subroutine at &lt;code&gt;0x15b2&lt;/code&gt; which at this point we know is the address of &lt;code&gt;MakeFunctions&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Step 4&lt;/h2&gt;
&lt;p&gt;We extracted two useful information from this code. First, the vector table is at address &lt;code&gt;0x1a7c&lt;/code&gt;, and second the &lt;code&gt;MakeFunctions&lt;/code&gt; subroutine is at address &lt;code&gt;0x15b2&lt;/code&gt;. This latter will be useful to double check the content of the vector table.&lt;/p&gt;
&lt;p&gt;After &lt;code&gt;MakeFunctions&lt;/code&gt; has been executed the code returns and the next instruction stores the final size of the jump table 16 bytes after the address contained in &lt;code&gt;a6&lt;/code&gt;. With the help of the structures shown above we know that at that offset we can find the &lt;code&gt;LIB_NEGSIZE&lt;/code&gt; field, that contains the size of the jump table (number of bytes before the library).&lt;/p&gt;
&lt;p&gt;It's time to check if what we found is correct. There should be a table at address &lt;code&gt;0x1a7c&lt;/code&gt; that contains function addresses in the order listed by the include file &lt;code&gt;include_i/exec/exec_lib.i&lt;/code&gt;. As &lt;code&gt;MakeFunctions&lt;/code&gt; in that file is listed at the 11th place we can check if the table is consistent. That address should point a function at &lt;code&gt;0x15b2&lt;/code&gt;, according to the previous code.&lt;/p&gt;
&lt;p&gt;The values at &lt;code&gt;0x1a7c&lt;/code&gt; are the following &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;00001a7c:&lt;/span&gt; &lt;span class="mi"&gt;08a0&lt;/span&gt;
&lt;span class="nl"&gt;00001a7e:&lt;/span&gt; &lt;span class="mi"&gt;08a8&lt;/span&gt;
&lt;span class="nl"&gt;00001a80:&lt;/span&gt; &lt;span class="mi"&gt;08ac&lt;/span&gt;
&lt;span class="nl"&gt;00001a82:&lt;/span&gt; &lt;span class="mi"&gt;08ac&lt;/span&gt;
&lt;span class="nl"&gt;00001a84:&lt;/span&gt; &lt;span class="mi"&gt;ee6a&lt;/span&gt;
&lt;span class="nl"&gt;00001a86:&lt;/span&gt; &lt;span class="mi"&gt;f420&lt;/span&gt;
&lt;span class="nl"&gt;00001a88:&lt;/span&gt; &lt;span class="mi"&gt;f446&lt;/span&gt;
&lt;span class="nl"&gt;00001a8a:&lt;/span&gt; &lt;span class="mi"&gt;04f8&lt;/span&gt;
&lt;span class="nl"&gt;00001a8c:&lt;/span&gt; &lt;span class="mi"&gt;f4a0&lt;/span&gt;
&lt;span class="nl"&gt;00001a8e:&lt;/span&gt; &lt;span class="mi"&gt;f4ea&lt;/span&gt;
&lt;span class="nl"&gt;00001a90:&lt;/span&gt; &lt;span class="mi"&gt;f58e&lt;/span&gt;
&lt;span class="nl"&gt;00001a92:&lt;/span&gt; &lt;span class="mi"&gt;f0b0&lt;/span&gt;
&lt;span class="nl"&gt;00001a94:&lt;/span&gt; &lt;span class="mi"&gt;f188&lt;/span&gt;
&lt;span class="nl"&gt;00001a96:&lt;/span&gt; &lt;span class="mi"&gt;faac&lt;/span&gt;
&lt;span class="nl"&gt;00001a98:&lt;/span&gt; &lt;span class="mi"&gt;fb36&lt;/span&gt;
&lt;span class="nl"&gt;00001a9a:&lt;/span&gt; &lt;span class="mi"&gt;f080&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The file &lt;code&gt;include_i/exec/exec_lib.i&lt;/code&gt; doesn't contain the first 4 reserved vectors (the functions &lt;code&gt;Open&lt;/code&gt;, &lt;code&gt;Close&lt;/code&gt;, &lt;code&gt;Expunge&lt;/code&gt;, and the reserved space), so considering that those are in the vector table we should check the 15th, were we find &lt;code&gt;0xfb36&lt;/code&gt;. This is an offset relative to the beginning of the table, so the function is at &lt;code&gt;0x1a7c + 0xfb36 = 0x15b2&lt;/code&gt; (addresses are 16 bits numbers), as we already discovered.&lt;/p&gt;
&lt;p&gt;This shows that our investigation is correct. The Kickstart 1.3 vector table is at address &lt;code&gt;0x1a7c&lt;/code&gt; and from there we can reach and analyse all the functions contained in the base Amiga library.&lt;/p&gt;
&lt;h1&gt;Resources&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Amiga System Programmers Guide, Abacus (&lt;a href="https://archive.org/details/Amiga_System_Programmers_Guide_1988_Abacus"&gt;pdf here&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://amigadev.elowar.com"&gt;AmigaOS Developer Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Amiga Forever package sold by Cloanto &lt;a href="www.amigaforever.com"&gt;here&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Updates&lt;/h1&gt;
&lt;p&gt;2018-06-23: As &lt;a href="https://new.reddit.com/user/Malor"&gt;Malor&lt;/a&gt; pointed out on Reddit (&lt;a href="https://new.reddit.com/r/programming/comments/8pkgk0/exploring_the_amiga_part_1/e0cifax"&gt;here&lt;/a&gt;) there is no need to own the original hardware, as licenses are still sold by Cloanto. Thanks Malor!&lt;/p&gt;
&lt;h1&gt;Feedback&lt;/h1&gt;
&lt;p&gt;Feel free to reach me on &lt;a href="https://twitter.com/thedigicat"&gt;Twitter&lt;/a&gt; if you have questions. The &lt;a href="http://github.com/TheDigitalCatOnline/thedigitalcatonline.github.com/issues"&gt;GitHub issues&lt;/a&gt; page is the best place to submit corrections.&lt;/p&gt;</content><category term="assembly"></category><category term="amiga"></category><category term="retroprogramming"></category></entry><entry><title>Exploring the Amiga - Part 2</title><link href="http://blog.thedigitalcatonline.com/blog/2018/05/28/exploring-the-amiga-2/" rel="alternate"></link><published>2018-05-28T15:00:00+01:00</published><updated>2018-05-28T15:00:00+01:00</updated><author><name>Leonardo Giordani</name></author><id>tag:blog.thedigitalcatonline.com,2018-05-28:/blog/2018/05/28/exploring-the-amiga-2/</id><summary type="html"></summary><content type="html">&lt;h1&gt;The library jump table&lt;/h1&gt;
&lt;p&gt;As already mentioned when a library is loaded in memory a jump table is created just before the library base address. This table contains the addresses of the functions exposed by the library, and Exec itself has one.&lt;/p&gt;
&lt;p&gt;The jump table functions order for the Exec library is specified in one of the include files provided by the NDK, namely &lt;code&gt;include_i/exec/exec_lib.i&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;FUNCDEF&lt;/span&gt; &lt;span class="n"&gt;Supervisor&lt;/span&gt;
    &lt;span class="n"&gt;FUNCDEF&lt;/span&gt; &lt;span class="n"&gt;execPrivate1&lt;/span&gt;
    &lt;span class="n"&gt;FUNCDEF&lt;/span&gt; &lt;span class="n"&gt;execPrivate2&lt;/span&gt;
    &lt;span class="n"&gt;FUNCDEF&lt;/span&gt; &lt;span class="n"&gt;execPrivate3&lt;/span&gt;
    &lt;span class="n"&gt;...&lt;/span&gt;
    &lt;span class="n"&gt;FUNCDEF&lt;/span&gt; &lt;span class="n"&gt;OpenLibrary&lt;/span&gt;
    &lt;span class="n"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see this file makes use of the &lt;code&gt;FUNCDEF&lt;/code&gt; macro, which is not provided and has to be implemented by the coder. The idea of the macro is very simple: as the order of the jump table does not change we can just replace the first &lt;code&gt;FUNCDEF&lt;/code&gt; with the offset of the first function in the library and then increment this offset with the default size of the jump address. The expected output of the macro is&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;_LVOSupervisor&lt;/span&gt;     &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;
    &lt;span class="n"&gt;_LVOexecPrivate1&lt;/span&gt;   &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;36&lt;/span&gt;
    &lt;span class="n"&gt;_LVOexecPrivate2&lt;/span&gt;   &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;
    &lt;span class="n"&gt;_LVOexecPrivate3&lt;/span&gt;   &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;48&lt;/span&gt;
    &lt;span class="n"&gt;...&lt;/span&gt;
    &lt;span class="n"&gt;_LVOOpenLibrary&lt;/span&gt;    &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;552&lt;/span&gt;
    &lt;span class="n"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Please note that the name of the function has been replaced by another string prepending &lt;code&gt;_LVO&lt;/code&gt; to avoid clashes with the actual function definition (&lt;code&gt;LVO&lt;/code&gt; stands for Library Vector Offset).&lt;/p&gt;
&lt;p&gt;The above figures come from the Special Constants contained in the &lt;code&gt;include_i/exec/libraries.i&lt;/code&gt; file&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;*------ Special Constants ---------------------------------------&lt;/span&gt;
&lt;span class="n"&gt;LIB_VECTSIZE&lt;/span&gt;    &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;       &lt;span class="c1"&gt;;Each library entry takes 6 bytes&lt;/span&gt;
&lt;span class="n"&gt;LIB_RESERVED&lt;/span&gt;    &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;       &lt;span class="c1"&gt;;Exec reserves the first 4 vectors&lt;/span&gt;
&lt;span class="n"&gt;LIB_BASE&lt;/span&gt;    &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="n"&gt;LIB_VECTSIZE&lt;/span&gt;
&lt;span class="n"&gt;LIB_USERDEF&lt;/span&gt; &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="n"&gt;LIB_BASE&lt;/span&gt;&lt;span class="p"&gt;-(&lt;/span&gt;&lt;span class="n"&gt;LIB_RESERVED&lt;/span&gt;&lt;span class="p"&gt;*&lt;/span&gt;&lt;span class="n"&gt;LIB_VECTSIZE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;;First user func&lt;/span&gt;
&lt;span class="n"&gt;LIB_NONSTD&lt;/span&gt;  &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="n"&gt;LIB_USERDEF&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;AS you can see from the comments, Exec reserves the first 4 vectors, so the first function's address is &lt;code&gt;LIB_USERDEF&lt;/code&gt;. To understand why the addresses are negative and how the offset is computed let's get a snapshot of the library once it has been loaded in memory&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;                              HIGHER MEMORY ADDRESSES
                            +-------------------------+
Last byte of the            | End of the library      |
library loaded in ---------&amp;gt;+-------------------------+
memory                      | [...]                   |
                            +-------------------------+
                            | Content of the library  |
                            +-------------------------+
                            | Library structure       |
Library base address ------&amp;gt;+-------------------------+
                            | 1st reserved vector     |
                            +-------------------------+&amp;lt;--- LIB_BASE
                            | 2nd reserved vector     |
                            +-------------------------+&amp;lt;--+
                            | 3rd reserved vector     |   | LIB_VECTSIZE
                            +-------------------------+&amp;lt;--+
                            | 4th reserved vector     |
                            +-------------------------+
                            | 1st defined function    |
                            +-------------------------+&amp;lt;--- LIB_USERDEF
                            | 2nd defined function    |
                            +-------------------------+
                            | [...]                   |
                            +-------------------------+
First byte of the           | End of the jump table   |
library loaded in ---------&amp;gt;+-------------------------+
memory                        LOWER MEMORY ADDRESSES
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can find an official version of this in the &lt;a href="http://amigadev.elowar.com/read/ADCD_2.1/AmigaMail_Vol2_guide/node0189.html"&gt;documentation&lt;/a&gt;. Pay attention that the picture in the documentation represents memory upside down, with lower memory addresses towards the top of the page.&lt;/p&gt;
&lt;p&gt;As you can see the library is loaded as expected from the base address towards the higher memory addresses, but at the same time the jump table is prefixed &lt;em&gt;in reverse order&lt;/em&gt;. This is done to allow you to find the address of a function with a simple (negative) indexing instead of a more complex algorithm. Function number 1 is at address &lt;code&gt;-1 * address_size&lt;/code&gt;, function number 2 at address &lt;code&gt;-2 * address_size&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;This is why we use negative offsets to call library functions but positive ones to access the library data and structures.&lt;/p&gt;
&lt;p&gt;You can also see from the figure where the Special Constants &lt;code&gt;LIB_BASE&lt;/code&gt; and &lt;code&gt;LIB_USERDEF&lt;/code&gt; are located. The actual values are&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;LIB_BASE&lt;/span&gt;    &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="n"&gt;LIB_USERDEF&lt;/span&gt; &lt;span class="o"&gt;EQU&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A good definition of the &lt;code&gt;FUNCDEF&lt;/code&gt; macro, thus, is the following&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="o"&gt;INCLUDE&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;exec/libraries.i&amp;quot;&lt;/span&gt;

    &lt;span class="o"&gt;MACRO&lt;/span&gt;   &lt;span class="n"&gt;FUNCDEF&lt;/span&gt;
&lt;span class="n"&gt;_LVO&lt;/span&gt;&lt;span class="p"&gt;\&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;      &lt;span class="o"&gt;EQU&lt;/span&gt;      &lt;span class="n"&gt;FUNC_CNT&lt;/span&gt;
&lt;span class="n"&gt;FUNC_CNT&lt;/span&gt;    &lt;span class="o"&gt;SET&lt;/span&gt;      &lt;span class="n"&gt;FUNC_CNT&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="n"&gt;LIB_VECTSIZE&lt;/span&gt;
    &lt;span class="o"&gt;ENDM&lt;/span&gt;

&lt;span class="n"&gt;FUNC_CNT&lt;/span&gt;    &lt;span class="o"&gt;SET&lt;/span&gt;      &lt;span class="n"&gt;LIB_USERDEF&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The last line initializes the &lt;code&gt;FUNC_CNT&lt;/code&gt; symbol with the &lt;code&gt;LIB_USERDEF&lt;/code&gt; value. Then each call of the &lt;code&gt;FUNCDEF &amp;lt;arg&amp;gt;&lt;/code&gt; macro does two things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Creates the &lt;code&gt;_LVO&amp;lt;arg&amp;gt;&lt;/code&gt; symbol with value &lt;code&gt;FUNC_CNT&lt;/code&gt; (e.g. &lt;code&gt;_LVOSupervisor EQU -30&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Decrements the &lt;code&gt;FUNC_CNT&lt;/code&gt; symbol by &lt;code&gt;LIB_VECTSIZE&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Please note that the example &lt;code&gt;FUNCDEF&lt;/code&gt; that you can find (commented) in &lt;code&gt;libraries.i&lt;/code&gt; won't work out of the box as &lt;code&gt;FUNC_CNT&lt;/code&gt; is defined inside the macro itself, while it has to be already defined before the first use of the macro.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;*------ FUNCDEF is used to parse library offset tables.  Many applications&lt;/span&gt;
&lt;span class="c1"&gt;*------ need a special version of FUNCDEF - you provide your own macro&lt;/span&gt;
&lt;span class="c1"&gt;*------ to match your needs.  Here is an example:&lt;/span&gt;
&lt;span class="c1"&gt;*&lt;/span&gt;
&lt;span class="c1"&gt;*    FUNCDEF     MACRO&lt;/span&gt;
&lt;span class="c1"&gt;*    _LVO\1      EQU    FUNC_CNT&lt;/span&gt;
&lt;span class="c1"&gt;*    FUNC_CNT    SET    FUNC_CNT-6  * Standard offset-6 bytes each&lt;/span&gt;
&lt;span class="c1"&gt;*    FUNC_CNT    EQU    LIB_USERDEF * Skip 4 standard vectors&lt;/span&gt;
&lt;span class="c1"&gt;*                ENDM&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can put the &lt;code&gt;FUNCDEF&lt;/code&gt; macro code in a local include file like &lt;code&gt;funcdef.i&lt;/code&gt;. Including it your code allows you to use &lt;code&gt;_LVO&lt;/code&gt; prefixed labels for the functions that you want to load&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="o"&gt;INCLUDE&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;funcdef.i&amp;quot;&lt;/span&gt;
    &lt;span class="o"&gt;INCLUDE&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;exec/exec_lib.i&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;
    &lt;span class="k"&gt;clr&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;   &lt;span class="o"&gt;d0&lt;/span&gt;
    &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="nl"&gt;#libname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;
    &lt;span class="k"&gt;jsr&lt;/span&gt;     &lt;span class="n"&gt;_LVOOpenLibrary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nl"&gt;libname:&lt;/span&gt;
    &lt;span class="o"&gt;dc.b&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;somename.library&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finally, if you want to be even more explicit you can use the &lt;code&gt;CALLLIB&lt;/code&gt; macro defined in &lt;code&gt;libraries.i&lt;/code&gt; and write&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="o"&gt;INCLUDE&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;funcdef.i&amp;quot;&lt;/span&gt;
    &lt;span class="o"&gt;INCLUDE&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;exec/exec_lib.i&amp;quot;&lt;/span&gt;
    &lt;span class="o"&gt;INCLUDE&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;exec/libraries.i&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;
    &lt;span class="k"&gt;clr&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;   &lt;span class="o"&gt;d0&lt;/span&gt;
    &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt;  &lt;span class="nl"&gt;#libname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;
    &lt;span class="n"&gt;CALLLIB&lt;/span&gt; &lt;span class="n"&gt;_LVOOpenLibrary&lt;/span&gt;

&lt;span class="nl"&gt;libname:&lt;/span&gt;
    &lt;span class="o"&gt;dc.b&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;somename.library&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;The four reserved vectors&lt;/h1&gt;
&lt;p&gt;As we saw, the Amiga system reserves 4 vectors at the beginning of the jump table of a library. These 4 spaces host 3 standard functions that shall be provided by any library, &lt;code&gt;Open()&lt;/code&gt;, &lt;code&gt;Close()&lt;/code&gt;, and &lt;code&gt;Expunge()&lt;/code&gt;. The fourth slot is kept for possible future expansions and must contain a function that returns 0.&lt;/p&gt;
&lt;p&gt;The offsets of these functions are contained in the &lt;code&gt;include_i/exec/libraries.i&lt;/code&gt; file&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;*----------------------------------------------------------------&lt;/span&gt;
&lt;span class="c1"&gt;*&lt;/span&gt;
&lt;span class="c1"&gt;*   Standard Library Functions&lt;/span&gt;
&lt;span class="c1"&gt;*&lt;/span&gt;
&lt;span class="c1"&gt;*----------------------------------------------------------------&lt;/span&gt;

    &lt;span class="n"&gt;LIBINIT&lt;/span&gt; &lt;span class="n"&gt;LIB_BASE&lt;/span&gt;

    &lt;span class="n"&gt;LIBDEF&lt;/span&gt;  &lt;span class="n"&gt;LIB_OPEN&lt;/span&gt;
    &lt;span class="n"&gt;LIBDEF&lt;/span&gt;  &lt;span class="n"&gt;LIB_CLOSE&lt;/span&gt;
    &lt;span class="n"&gt;LIBDEF&lt;/span&gt;  &lt;span class="n"&gt;LIB_EXPUNGE&lt;/span&gt; &lt;span class="c1"&gt;; must exist in all libraries&lt;/span&gt;
    &lt;span class="n"&gt;LIBDEF&lt;/span&gt;  &lt;span class="n"&gt;LIB_EXTFUNC&lt;/span&gt; &lt;span class="c1"&gt;; for future expansion - must return zero.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;the effect of the above macros with the previous constants is&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;LIB_OPEN&lt;/span&gt;        &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="n"&gt;LIB_CLOSE&lt;/span&gt;       &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;
&lt;span class="n"&gt;LIB_EXPUNGE&lt;/span&gt;     &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;
&lt;span class="n"&gt;LIB_EXTFUNC&lt;/span&gt;     &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;24&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can try to follow the definitions of the &lt;code&gt;LIBINIT&lt;/code&gt; and &lt;code&gt;LIBDEF&lt;/code&gt; macros to obtain the same result.&lt;/p&gt;
&lt;h1&gt;Types and structures&lt;/h1&gt;
&lt;p&gt;Let's see how the Exec library defines its types, which are the base components of the Amiga system. The main entry point for this investigation is the &lt;code&gt;include_i/exec/types.i&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;When working with data structures in Assembly, everything is expressed in terms of offsets. The main idea behind structures is to create something like this&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;STRUCT1&lt;/span&gt;         &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="o"&gt;OFFSET&lt;/span&gt;          &lt;span class="o"&gt;SET&lt;/span&gt;     &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;FIELD1&lt;/span&gt;          &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="o"&gt;OFFSET&lt;/span&gt;
&lt;span class="o"&gt;OFFSET&lt;/span&gt;          &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="o"&gt;OFFSET&lt;/span&gt;&lt;span class="p"&gt;+&lt;/span&gt;&lt;span class="n"&gt;SIZE_OF_FIELD1&lt;/span&gt;
&lt;span class="n"&gt;FIELD2&lt;/span&gt;          &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="o"&gt;OFFSET&lt;/span&gt;
&lt;span class="o"&gt;OFFSET&lt;/span&gt;          &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="o"&gt;OFFSET&lt;/span&gt;&lt;span class="p"&gt;+&lt;/span&gt;&lt;span class="n"&gt;SIZE_OF_FIELD2&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;STRUCT1_SIZE&lt;/span&gt;    &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="o"&gt;OFFSET&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;which, once run through the macro expansion, creates the following code&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;STRUCT1&lt;/span&gt;         &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;FIELD1&lt;/span&gt;          &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;FIELD2&lt;/span&gt;          &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="n"&gt;SIZE_OF_FIELD1&lt;/span&gt;
&lt;span class="n"&gt;FIIELD3&lt;/span&gt;         &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="n"&gt;SIZE_OF_FIELD1&lt;/span&gt;&lt;span class="p"&gt;+&lt;/span&gt;&lt;span class="n"&gt;SIZE_OF_FIELD2&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;STRUCT1_SIZE&lt;/span&gt;    &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="n"&gt;SIZE_OF_FIELD1&lt;/span&gt;&lt;span class="p"&gt;+&lt;/span&gt;&lt;span class="n"&gt;...&lt;/span&gt;&lt;span class="p"&gt;+&lt;/span&gt;&lt;span class="n"&gt;SIZE_OF_FIELDn&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So, the type macros are all defined with code like this&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;TYPENAME&lt;/span&gt;    &lt;span class="o"&gt;MACRO&lt;/span&gt;
&lt;span class="p"&gt;\&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;          &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="n"&gt;SOFFSET&lt;/span&gt;
&lt;span class="n"&gt;SOFFSET&lt;/span&gt;     &lt;span class="o"&gt;SET&lt;/span&gt;     &lt;span class="n"&gt;SOFFSET&lt;/span&gt;&lt;span class="p"&gt;+&lt;/span&gt;&lt;span class="n"&gt;SIZE_OF_TYPE&lt;/span&gt;
            &lt;span class="o"&gt;ENDM&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;For example the &lt;code&gt;BYTE&lt;/code&gt; macro is&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;BYTE&lt;/span&gt;        &lt;span class="o"&gt;MACRO&lt;/span&gt;       &lt;span class="c1"&gt;; byte (8 bits)&lt;/span&gt;
&lt;span class="p"&gt;\&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;          &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="n"&gt;SOFFSET&lt;/span&gt;
&lt;span class="n"&gt;SOFFSET&lt;/span&gt;     &lt;span class="o"&gt;SET&lt;/span&gt;     &lt;span class="n"&gt;SOFFSET&lt;/span&gt;&lt;span class="p"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
            &lt;span class="o"&gt;ENDM&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note that the field is defined with &lt;code&gt;EQU&lt;/code&gt; to avoid unwanted overwrites, while &lt;code&gt;SOFFSET&lt;/code&gt; uses &lt;code&gt;SET&lt;/code&gt; that allows to redefine the symbol.&lt;/p&gt;
&lt;p&gt;Let's see now how a real structure is defined. A good example is &lt;code&gt;LN&lt;/code&gt; defined in &lt;code&gt;include_i/exec/nodes.i&lt;/code&gt; which represents a node of a linked list.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class="n"&gt;STRUCTURE&lt;/span&gt;    &lt;span class="n"&gt;LN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="c1"&gt;; List Node&lt;/span&gt;
    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;LN_SUCC&lt;/span&gt; &lt;span class="c1"&gt;; Pointer to next (successor)&lt;/span&gt;
    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;LN_PRED&lt;/span&gt; &lt;span class="c1"&gt;; Pointer to previous (predecessor)&lt;/span&gt;
    &lt;span class="n"&gt;UBYTE&lt;/span&gt;   &lt;span class="n"&gt;LN_TYPE&lt;/span&gt;
    &lt;span class="n"&gt;BYTE&lt;/span&gt;    &lt;span class="n"&gt;LN_PRI&lt;/span&gt;  &lt;span class="c1"&gt;; Priority, for sorting&lt;/span&gt;
    &lt;span class="n"&gt;APTR&lt;/span&gt;    &lt;span class="n"&gt;LN_NAME&lt;/span&gt; &lt;span class="c1"&gt;; ID string, null terminated&lt;/span&gt;
    &lt;span class="n"&gt;LABEL&lt;/span&gt;   &lt;span class="n"&gt;LN_SIZE&lt;/span&gt; &lt;span class="c1"&gt;; Note: word aligned&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;STRUCTURE&lt;/code&gt; macro is defined in &lt;code&gt;types.i&lt;/code&gt; as&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;STRUCTURE&lt;/span&gt;   &lt;span class="o"&gt;MACRO&lt;/span&gt;       &lt;span class="c1"&gt;; structure name, initial offset&lt;/span&gt;
&lt;span class="p"&gt;\&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;          &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;SOFFSET&lt;/span&gt;     &lt;span class="o"&gt;SET&lt;/span&gt;     &lt;span class="p"&gt;\&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
            &lt;span class="o"&gt;ENDM&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And the resulting declarations, once the macros have been expanded, are the following&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;LN&lt;/span&gt;          &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;LN_SUCC&lt;/span&gt;     &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;LN_PRED&lt;/span&gt;     &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="n"&gt;LN_TYPE&lt;/span&gt;     &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="n"&gt;LN_PRI&lt;/span&gt;      &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="mi"&gt;9&lt;/span&gt;
&lt;span class="n"&gt;LN_NAME&lt;/span&gt;     &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="n"&gt;LN_SIZE&lt;/span&gt;     &lt;span class="o"&gt;EQU&lt;/span&gt;     &lt;span class="mi"&gt;14&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see the field names are just offsets inside the structure, and there is no specific padding at the end to align the structure. In this case there is no need, as the structure size is already a multiple of a word (14 bytes).&lt;/p&gt;
&lt;h2&gt;How to align structures&lt;/h2&gt;
&lt;p&gt;If we need to align the bytes however we can use a little binary trick. If you ignore the least significant bit of a binary number you convert it to the nearest even number (downwards). An example in Python is&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;bin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;0b1101&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;bin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;0b1100&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and even numbers are separated exactly by two positions. So if we get the current offset, we increase it by one and round down to the nearest integer we are aligning the offset to multiples of a word (2 bytes). The &lt;code&gt;ALIGNWORD&lt;/code&gt; macro in the &lt;code&gt;include_i/exec/types.i&lt;/code&gt; file implements exactly this algorithm&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;ALIGNWORD&lt;/span&gt;   &lt;span class="o"&gt;MACRO&lt;/span&gt;       &lt;span class="c1"&gt;; Align structure offset to nearest word&lt;/span&gt;
&lt;span class="n"&gt;SOFFSET&lt;/span&gt;     &lt;span class="o"&gt;SET&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SOFFSET&lt;/span&gt;&lt;span class="p"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&amp;amp;&lt;/span&gt;&lt;span class="mi"&gt;$fffffffe&lt;/span&gt;
            &lt;span class="o"&gt;ENDM&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This can be seen in action in the &lt;code&gt;CardHandle&lt;/code&gt; structure defined in &lt;code&gt;include_i/resources/card.i&lt;/code&gt;.&lt;/p&gt;
&lt;h1&gt;Resources&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Amiga System Programmers Guide, Abacus (&lt;a href="https://archive.org/details/Amiga_System_Programmers_Guide_1988_Abacus"&gt;pdf here&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://amigadev.elowar.com"&gt;AmigaOS Developer Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Feedback&lt;/h1&gt;
&lt;p&gt;Feel free to reach me on &lt;a href="https://twitter.com/thedigicat"&gt;Twitter&lt;/a&gt; if you have questions. The &lt;a href="http://github.com/TheDigitalCatOnline/thedigitalcatonline.github.com/issues"&gt;GitHub issues&lt;/a&gt; page is the best place to submit corrections.&lt;/p&gt;</content><category term="assembly"></category><category term="amiga"></category><category term="retroprogramming"></category></entry><entry><title>Exploring the Amiga - Part 1</title><link href="http://blog.thedigitalcatonline.com/blog/2018/05/28/exploring-the-amiga-1/" rel="alternate"></link><published>2018-05-28T14:00:00+01:00</published><updated>2018-05-28T14:00:00+01:00</updated><author><name>Leonardo Giordani</name></author><id>tag:blog.thedigitalcatonline.com,2018-05-28:/blog/2018/05/28/exploring-the-amiga-1/</id><summary type="html"></summary><content type="html">&lt;p&gt;Recently I decided to give some time to retroprogramming, and in particular to explore the architecture of some famous microcomputer and consoles of the 80s and 90s. Glorious 8-bit systems like the ZX Spectrum, the Commodore 64, or the Nintendo Entertainment System. 16-bits giants the likes of the Amiga, its (eventually winning) MS-DOS-based counterparts running on the early x86 architectures, the immortal Nintendo Super Famicom and SEGA Genesis.&lt;/p&gt;
&lt;p&gt;I am deeply convinced that learning architectures is a perfect way to become a better programmer, even now that we have 64-bits processors, fifth generation languages, and Internet. Those old systems had many limitations and to get interesting results the programmer has to know the hardware and exploit every single bit of power it can deliver.&lt;/p&gt;
&lt;p&gt;This is sometimes not true any more nowadays. On the one hand this is good, as it allows us to concentrate on business decisions and on higher layer of abstraction. On the other hand it was and it will always be useful for a programmer to face a limited system and to try to get the maximum out of it.&lt;/p&gt;
&lt;p&gt;This series of posts is about the Commodore Amiga. Thousands of words have already been written on the Amiga, and I will not add anything but "milestone" to the adjectives used to describe it. This post and the following ones are not intended to be a complete and well-organised review of the architecture. Instead, they will be more a set of "lab notes" for myself that I write while I explore the platform. I put them on the blog in the hope that they will be useful for other programmers that try to crack the same problems.&lt;/p&gt;
&lt;h1&gt;Assembly language and the Amiga&lt;/h1&gt;
&lt;p&gt;If you want to write Assembly programs for the Amiga you can either work directly on a real system or use a cross-compiler. I prefer to work on my Linux system because, as much as I like retro architectures, I also like the power of a good Unix system and a modern editor.&lt;/p&gt;
&lt;p&gt;Cross-compiling is a very simple concept: instead of compiling source code and creating binaries for the architecture you are running the compiler on, you create binaries for a different architecture. In this case the host architecture is Linux/amd64 and the target architecture is Amiga.&lt;/p&gt;
&lt;p&gt;As this is not the only project I am following at the moment, I created a directory to host everything I need for the Amiga development: compiler, documentation, scripts.&lt;/p&gt;
&lt;h2&gt;Install vasm&lt;/h2&gt;
&lt;p&gt;On Linux you can both use the GCC compiler or install vasm. This latter uses the same syntax as the standard Amiga assemblers, especially for compiler directives like &lt;code&gt;macro&lt;/code&gt; and &lt;code&gt;include&lt;/code&gt;, thus making it easier to pick up and use code published in books and in magazines during the 80s.&lt;/p&gt;
&lt;p&gt;To install the latest vasm you can run the following code&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wget -q &lt;span class="s2"&gt;&amp;quot;http://sun.hasenbraten.de/vasm/release/vasm.tar.gz&amp;quot;&lt;/span&gt;
tar xvf vasm.tar.gz &lt;span class="c1"&gt;# The file is not actually gzipped&lt;/span&gt;
rm vasm.tar.gz
&lt;span class="nb"&gt;cd&lt;/span&gt; vasm
make &lt;span class="nv"&gt;CPU&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;m68k &lt;span class="nv"&gt;SYNTAX&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;mot
&lt;span class="nb"&gt;cd&lt;/span&gt; ..
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Install a disassembler&lt;/h2&gt;
&lt;p&gt;The vbcc suite written by Volker Barthelmann contains a disassembler for the M68k architecture that you can find &lt;a href="http://sun.hasenbraten.de/~frank/projects/"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A disassembler is a handy tool that can reveal a lot about how a program works. You can install it with the following code&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wget -q &lt;span class="s2"&gt;&amp;quot;http://sun.hasenbraten.de/~frank/projects/download/vdam68k.tar.gz&amp;quot;&lt;/span&gt;
tar xvzf vdam68k.tar.gz 
&lt;span class="nb"&gt;cd&lt;/span&gt; vda/M68k/
make
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;which will create the &lt;code&gt;vda/M68k/vda68k&lt;/code&gt; that you can use to disassemble Amiga programs or ROM dumps.&lt;/p&gt;
&lt;h2&gt;Install the NDK&lt;/h2&gt;
&lt;p&gt;The Native Development Kit (the Amiga SDK) contains include files that can be very helpful (though not strictly necessary) when developing. Unfortunately the NDK is still copyrighted by some of the guys that are trying to resurrect the Amiga. This latter idea is nice, but I really do not understand how preventing distribution of development documentation about a platform dead more than 20 years ago might help such a project.&lt;/p&gt;
&lt;p&gt;Whatever, you can get an old version of the Amiga Developer CD &lt;a href="https://archive.org/details/amiga-developer-cd-v1_1"&gt;here&lt;/a&gt;. This contains the NDK version 3.1 which is enough for what we are going to learn in this series.&lt;/p&gt;
&lt;p&gt;You may want to rename the &lt;code&gt;Includes&amp;amp;Libs&lt;/code&gt; directory to &lt;code&gt;Includes_Libs&lt;/code&gt; to simplify its access by the compiler command line (&lt;code&gt;&amp;amp;&lt;/code&gt; is a special character in bash).&lt;/p&gt;
&lt;h2&gt;Helper script and test&lt;/h2&gt;
&lt;p&gt;I created a &lt;code&gt;asm.sh&lt;/code&gt; helper script to simplify the development process&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;

&lt;span class="nv"&gt;BASE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/where/you/put/everything&amp;quot;&lt;/span&gt;

&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;BASE&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;/vasm/vasmm68k_mot -kick1hunks -Fhunkexe -I&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;BASE&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;/NDK_3.1/Include_Libs/include_i -o &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;1&lt;/span&gt;&lt;span class="p"&gt;/.asm/&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt; -nosym &lt;span class="nv"&gt;$1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Don't forget to run &lt;code&gt;chmod 775 asm.sh&lt;/code&gt; to make the script executable. Now run the following command&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; -e &lt;span class="s2"&gt;&amp;quot;loop:\n btst #6,\$bfe001\n bne loop\n rts\n&amp;quot;&lt;/span&gt; &amp;gt; test.asm &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; ./asm.sh test.asm
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This compiles a very small program that loops until you press the right mouse button. If everything has been correctly installed you should get the following output&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vasm &lt;span class="m"&gt;1&lt;/span&gt;.8c &lt;span class="o"&gt;(&lt;/span&gt;c&lt;span class="o"&gt;)&lt;/span&gt; in &lt;span class="m"&gt;2002&lt;/span&gt;-2018 Volker Barthelmann
vasm M68k/CPU32/ColdFire cpu backend &lt;span class="m"&gt;2&lt;/span&gt;.3b &lt;span class="o"&gt;(&lt;/span&gt;c&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="m"&gt;2002&lt;/span&gt;-2017 Frank Wille
vasm motorola syntax module &lt;span class="m"&gt;3&lt;/span&gt;.11c &lt;span class="o"&gt;(&lt;/span&gt;c&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="m"&gt;2002&lt;/span&gt;-2018 Frank Wille
vasm hunk format output module &lt;span class="m"&gt;2&lt;/span&gt;.9b &lt;span class="o"&gt;(&lt;/span&gt;c&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="m"&gt;2002&lt;/span&gt;-2017 Frank Wille

CODE&lt;span class="o"&gt;(&lt;/span&gt;acrx2&lt;span class="o"&gt;)&lt;/span&gt;:              &lt;span class="m"&gt;12&lt;/span&gt; bytes
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And running the &lt;code&gt;file&lt;/code&gt; command should return the correct type&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ file &lt;span class="nb"&gt;test&lt;/span&gt;
test: AmigaOS loadseg&lt;span class="o"&gt;()&lt;/span&gt;ble executable/binary
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;LEA, the PC and the relative offset&lt;/h1&gt;
&lt;p&gt;In Assembly you can manage memory cells using either their content or the address, as you can do with pointers in C or similar concepts in other high-level languages. You can also set labels that the assembler will convert in instruction addresses, but these are (almost) always relative to the beginning of the code itself, as the code may be loaded anywhere in memory.&lt;/p&gt;
&lt;p&gt;This means that, generally speaking, all the addresses we use when we branch to other parts of the code should be relative to the current instruction.&lt;/p&gt;
&lt;p&gt;The Motorola 68k calls this addressing mode &lt;em&gt;Program Counter Indirect with Displacement Mode&lt;/em&gt;. Its description contained in the Programmer's Reference Manual is&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In this mode, the operand is in memory. The address of the operand is the sum of the address in the program counter (PC) and the sign-extended 16-bit displacement integer in the extension word. The value in the PC is the address of the extension word.&lt;/p&gt;
&lt;p&gt;(2.2.11, page 13)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The usual assembler syntax for this addressing mode is &lt;code&gt;(d16,PC)&lt;/code&gt; or &lt;code&gt;d16(PC)&lt;/code&gt;, where &lt;code&gt;d16&lt;/code&gt; is a 16-bits displacement. The &lt;code&gt;lea&lt;/code&gt; instruction, for example, supports this mode, so we can find code like&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;0364:&lt;/span&gt; &lt;span class="mi"&gt;41fa&lt;/span&gt; &lt;span class="mi"&gt;ffa6&lt;/span&gt;         &lt;span class="k"&gt;lea&lt;/span&gt;     &lt;span class="mi"&gt;0x30c&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;a0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here the instruction is stored at address &lt;code&gt;0x0364&lt;/code&gt; and it loads in the &lt;code&gt;a0&lt;/code&gt; register the &lt;em&gt;effective address&lt;/em&gt; of the instruction at &lt;code&gt;0x030c&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Pay attention: since your code starts always at address &lt;code&gt;0x0&lt;/code&gt;, you might be tempted to store the value &lt;code&gt;0x030c&lt;/code&gt; into &lt;code&gt;a0&lt;/code&gt; and go on. You want however to load the address that instruction has at runtime, which will be different from the current one. The displacement, however, will be the same, as the code doesn't change its form, and this is why this addressing mode is useful.&lt;/p&gt;
&lt;h2&gt;Relative offset encoding&lt;/h2&gt;
&lt;p&gt;A question may arise, then: why does the code show the address &lt;code&gt;0x30&lt;/code&gt; if the displacement is relative?&lt;/p&gt;
&lt;p&gt;Let's dig into the binary representation of the instruction to see how the processor receives it. The value &lt;code&gt;0x41faffa6&lt;/code&gt; in binary form is &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;01000001111110101111111110100110
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If we split it according to the Motorola 68k opcodes scheme (Programmer's Reference Manual, Section 8) we get&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0100 000 111 111010 1111111110100110
^    ^       ^
lea  a0      (d16,PC)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So we know this is a &lt;code&gt;lea&lt;/code&gt; to &lt;code&gt;a0&lt;/code&gt; using Program Counter with Displacement. The address argument is &lt;code&gt;1111111110100110&lt;/code&gt;, which has to be interpreted as a "sign-extended 16-bit displacement integer" as the Reference Manual stated.
The value is the two's complement representation of the decimal &lt;code&gt;-90&lt;/code&gt;, and since the PC is pointing at the address itself (&lt;code&gt;0x0366&lt;/code&gt;) the resulting address is &lt;code&gt;0x0366 - 90&lt;/code&gt;, which gives &lt;code&gt;0x030c&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The fact that the PC is pointing at the address might be overlooked. The manual says&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The value in the PC is the address of the extension word.
2.2.11 (2-13)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So, while the Assembly code uses the correct value for simplicity's sake, the actual opcode contains a true displacement from the current position.&lt;/p&gt;
&lt;h1&gt;How to open a library&lt;/h1&gt;
&lt;p&gt;When you code in a high level language like C you usually refer to functions of an external library in your code and then provide the library object files on the compiler command line. The code of the library is either included in the code of your program or loaded into memory at runtime (shared libraries), but in both cases the function call is, at the machine language level, just a jump to a different address in memory.&lt;/p&gt;
&lt;p&gt;If you write a program directly in Assembly language things are not different, you can always rely on the linker to properly address external libraries. In a platform like Amiga, however, it's custom to access the system libraries in a direct way, manually jumping to the right address, which is why sometimes tutorials and books contain "magic numbers".&lt;/p&gt;
&lt;p&gt;When the Amiga OS loads a library in memory the Exec master library analyses its structure and creates the so-called &lt;em&gt;jump table&lt;/em&gt;. This is nothing more than an array that lists the addresses of the functions exposed by the library. This is a very simple and effective way to let the OS free to load the library anywhere in memory (relocation).&lt;/p&gt;
&lt;p&gt;The Exec master library is not different, but this library is loaded as part of the bootstrap process, and the base address is always stored in memory location &lt;code&gt;0x4&lt;/code&gt;. To use one of Exec's functions, then, we just need to issue a &lt;code&gt;jsr &amp;lt;address&amp;gt;&lt;/code&gt; (&lt;code&gt;j&lt;/code&gt;ump to &lt;code&gt;s&lt;/code&gt;ub&lt;code&gt;r&lt;/code&gt;outine), where &lt;code&gt;&amp;lt;address&amp;gt;&lt;/code&gt; is the current position in memory of the function we want to call. Since we don't know the absolute address, being the library dynamically loaded, we use the library's jump table to retrieve the base address and get the function address as a fixed offset from the former.&lt;/p&gt;
&lt;p&gt;Many Amiga programmers knew (and know) the addresses by heart, which is fine since the Amiga OS promises not to change them among different versions. So, for example, the &lt;code&gt;OpenLibrary&lt;/code&gt; function can be found at address &lt;code&gt;-552&lt;/code&gt; relative to the library base, while &lt;code&gt;CloseLibrary&lt;/code&gt; is at &lt;code&gt;-414&lt;/code&gt;. To call the &lt;code&gt;OpenLibrary&lt;/code&gt; function, then, you need the following code&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;   &lt;span class="c1"&gt;; a6 = base address of Exec&lt;/span&gt;
    &lt;span class="k"&gt;jsr&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;552&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c1"&gt;; OpenLibrary()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The first instruction moves the value contained at address &lt;code&gt;0x4&lt;/code&gt; into the &lt;code&gt;a6&lt;/code&gt; register. This way the register will contain the base address of Exec. Then it jumps to the subroutine which address is 552 bytes before that base address. So, if &lt;code&gt;a6&lt;/code&gt; contains an address like &lt;code&gt;0x20000&lt;/code&gt; the code jumps to &lt;code&gt;0x1fdd8&lt;/code&gt; (&lt;code&gt;0x20000 - 552&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;OpenLibrary&lt;/code&gt; function, however, expects some parameters, as you can see on the documentation page &lt;code&gt;exec.library/OpenLibrary&lt;/code&gt; (&lt;a href="http://amigadev.elowar.com/read/ADCD_2.1/Includes_and_Autodocs_3._guide/node0222.html"&gt;here&lt;/a&gt;). The pointer to the library name has to be in the register &lt;code&gt;a1&lt;/code&gt; and the minimum accepted version in &lt;code&gt;d0&lt;/code&gt;. The code becomes&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;.w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;        &lt;span class="c1"&gt;; a6 = base address of Exec&lt;/span&gt;
    &lt;span class="k"&gt;clr&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt; &lt;span class="o"&gt;d0&lt;/span&gt;             &lt;span class="c1"&gt;; 0 = accept all versions&lt;/span&gt;
    &lt;span class="k"&gt;move&lt;/span&gt;&lt;span class="o"&gt;.l&lt;/span&gt; &lt;span class="nl"&gt;#libname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;a1&lt;/span&gt;   &lt;span class="c1"&gt;; a1 = address of the libname string&lt;/span&gt;
    &lt;span class="k"&gt;jsr&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;552&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;a6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;         &lt;span class="c1"&gt;; OpenLibrary()&lt;/span&gt;

&lt;span class="nl"&gt;libname:&lt;/span&gt;
    &lt;span class="o"&gt;dc.b&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;somename.library&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Resources&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Motorola M68000 Family Programmer's Reference Manual &lt;a href="https://www.nxp.com/docs/en/reference-manual/M68000PRM.pdf"&gt;PDF here&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://amigadev.elowar.com"&gt;AmigaOS Developer Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Feedback&lt;/h1&gt;
&lt;p&gt;Feel free to reach me on &lt;a href="https://twitter.com/thedigicat"&gt;Twitter&lt;/a&gt; if you have questions. The &lt;a href="http://github.com/TheDigitalCatOnline/thedigitalcatonline.github.com/issues"&gt;GitHub issues&lt;/a&gt; page is the best place to submit corrections.&lt;/p&gt;</content><category term="assembly"></category><category term="amiga"></category><category term="retroprogramming"></category></entry></feed>